; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\flash\obj\bsp_gps.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_gps.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\bsp_gps.crf ..\..\User\bsp\src\bsp_gps.c]
                          THUMB

                          AREA ||i.Analyze0183||, CODE, READONLY, ALIGN=2

                  Analyze0183 PROC
;;;938    */
;;;939    void Analyze0183(uint8_t *_ucaBuf, uint16_t _usLen)
000000  b570              PUSH     {r4-r6,lr}
;;;940    {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;941    
;;;942    	if (CheckXor(_ucaBuf, _usLen) != TRUE)
000006  f7fffffe          BL       CheckXor
00000a  2801              CMP      r0,#1
00000c  d148              BNE      |L1.160|
;;;943    	{
;;;944    		return;
;;;945    	}
;;;946    
;;;947    //	if (memcmp(_ucaBuf, "GPGGA,", 6) == 0)
;;;948    	if (memcmp(_ucaBuf, "GNGGA,", 6) == 0)
00000e  2206              MOVS     r2,#6
000010  a124              ADR      r1,|L1.164|
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       memcmp
000018  b320              CBZ      r0,|L1.100|
;;;949    	{
;;;950    		/* 字段 */
;;;951    		/*      0           1            2   3             4   5   6    7     8       9  10      11  12  13  14  */
;;;952    		
;;;953    		/* $GNGGA, 060821.000 , 3803.74436 , N , 11430.31395 , E , 1 , 10 , 2.5 , 181.2 , M , -16.0 , M ,  , *69  */
;;;954    		gpsGPGGA(_ucaBuf, _usLen);
;;;955    	}
;;;956    	else if (memcmp(_ucaBuf, "GPGSA,", 6) == 0)
00001a  2206              MOVS     r2,#6
00001c  a123              ADR      r1,|L1.172|
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       memcmp
000024  b320              CBZ      r0,|L1.112|
;;;957    	{
;;;958    		/* 字段 */
;;;959    		/*      0   1   2    3    4    5    6    7    8   9 10 11 12 13 14   15    16    17     18 */
;;;960    		
;;;961    		/* $GNGSA , A , 3 , 03 , 06 , 12 , 17 , 19 , 23 ,  ,  ,  ,  ,  ,  , 3.2 , 2.5 , 2.0 , 1*3C */
;;;962        /* $GNGSA , A , 3 , 08 , 12 , 13 , 19 ,    ,    ,  ,  ,  ,  ,  ,  , 3.2 , 2.5 , 2.0 , 4*31 */
;;;963    		gpsGPGSA(_ucaBuf, _usLen);
;;;964    	}
;;;965    	else if (memcmp(_ucaBuf, "GPGSV,", 6) == 0)
000026  2206              MOVS     r2,#6
000028  a122              ADR      r1,|L1.180|
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       memcmp
000030  b320              CBZ      r0,|L1.124|
;;;966    	{
;;;967    		/* 字段 */
;;;968    		/*    0    1   2    3   4    5    6     7    8    9    10    11   12   13   14    15   16   17   18    19   20 */
;;;969    		
;;;970    		/* $GPGSV, 2 , 1 , 08 , 03 , 20 , 043 , 37 , 06 , 66 , 312 , 37 , 12 , 23 , 316 , 33 , 17 , 67 , 084 , 24 , 0*65 */
;;;971    		/* $GPGSV, 2 , 2 , 08 , 19 , 75 , 029 , 32 , 22 ,    ,     , 29 , 23 , 18 , 080 , 27 , 33 ,    ,     , 19 , 0*6B */
;;;972    		gpsGPGSV(_ucaBuf, _usLen);
;;;973    	}
;;;974    	else if (memcmp(_ucaBuf, "GNRMC,", 6) == 0)
000032  2206              MOVS     r2,#6
000034  a121              ADR      r1,|L1.188|
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       memcmp
00003c  b320              CBZ      r0,|L1.136|
;;;975    	{
;;;976    		/* 字段 */
;;;977    		/*      0           1   2            3   4             5   6      7      8        9  11  12   13     14 */
;;;978    		
;;;979    		/* $GNRMC, 060820.000 , A , 3803.74437 , N , 11430.31400 , E , 0.00 , 0.00 , 160719 ,   ,   ,  A , V*04 */
;;;980    		gpsGPRMC(_ucaBuf, _usLen);
;;;981    	}
;;;982    	else if (memcmp(_ucaBuf, "GNVTG,", 6) == 0)
00003e  2206              MOVS     r2,#6
000040  a120              ADR      r1,|L1.196|
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       memcmp
000048  b320              CBZ      r0,|L1.148|
;;;983    	{
;;;984    		/* 字段 */
;;;985    		/*      0     1   2  3  4      5   6      7   8      9 */
;;;986    		
;;;987    		/* $GNVTG, 0.00 , T , , M , 0.00 , N , 0.00 , K , A*23 */
;;;988    		gpsGPVTG(_ucaBuf, _usLen);
;;;989    	}
;;;990    	else if (memcmp(_ucaBuf, "GNGLL,", 6) == 0)
00004a  2206              MOVS     r2,#6
00004c  a11f              ADR      r1,|L1.204|
00004e  4628              MOV      r0,r5
000050  f7fffffe          BL       memcmp
000054  2800              CMP      r0,#0
000056  d123              BNE      |L1.160|
;;;991    	{
;;;992    		/* 字段 */
;;;993    		/*      0           1   2             3   4            5   6      7 */
;;;994    		
;;;995    		/* $GNGLL, 3803.74436 , N , 11430.31395 , E , 060821.000 , A , A*4A */
;;;996    		gpsGPGLL(_ucaBuf, _usLen);
000058  4621              MOV      r1,r4
00005a  4628              MOV      r0,r5
00005c  e8bd4070          POP      {r4-r6,lr}
000060  f7ffbffe          B.W      gpsGPGLL
                  |L1.100|
000064  4621              MOV      r1,r4                 ;954
000066  4628              MOV      r0,r5                 ;954
000068  e8bd4070          POP      {r4-r6,lr}            ;954
00006c  f7ffbffe          B.W      gpsGPGGA
                  |L1.112|
000070  4621              MOV      r1,r4                 ;963
000072  4628              MOV      r0,r5                 ;963
000074  e8bd4070          POP      {r4-r6,lr}            ;963
000078  f7ffbffe          B.W      gpsGPGSA
                  |L1.124|
00007c  4621              MOV      r1,r4                 ;972
00007e  4628              MOV      r0,r5                 ;972
000080  e8bd4070          POP      {r4-r6,lr}            ;972
000084  f7ffbffe          B.W      gpsGPGSV
                  |L1.136|
000088  4621              MOV      r1,r4                 ;980
00008a  4628              MOV      r0,r5                 ;980
00008c  e8bd4070          POP      {r4-r6,lr}            ;980
000090  f7ffbffe          B.W      gpsGPRMC
                  |L1.148|
000094  4621              MOV      r1,r4                 ;988
000096  4628              MOV      r0,r5                 ;988
000098  e8bd4070          POP      {r4-r6,lr}            ;988
00009c  f7ffbffe          B.W      gpsGPVTG
                  |L1.160|
;;;997    	}
;;;998    }
0000a0  bd70              POP      {r4-r6,pc}
;;;999    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L1.164|
0000a4  474e4747          DCB      "GNGGA,",0
0000a8  412c00  
0000ab  00                DCB      0
                  |L1.172|
0000ac  47504753          DCB      "GPGSA,",0
0000b0  412c00  
0000b3  00                DCB      0
                  |L1.180|
0000b4  47504753          DCB      "GPGSV,",0
0000b8  562c00  
0000bb  00                DCB      0
                  |L1.188|
0000bc  474e524d          DCB      "GNRMC,",0
0000c0  432c00  
0000c3  00                DCB      0
                  |L1.196|
0000c4  474e5654          DCB      "GNVTG,",0
0000c8  472c00  
0000cb  00                DCB      0
                  |L1.204|
0000cc  474e474c          DCB      "GNGLL,",0
0000d0  4c2c00  
0000d3  00                DCB      0

                          AREA ||i.CheckXor||, CODE, READONLY, ALIGN=1

                  CheckXor PROC
;;;123    */
;;;124    uint8_t CheckXor(uint8_t *_ucaBuf, uint16_t _usLen)
000000  b57c              PUSH     {r2-r6,lr}
;;;125    {
;;;126    	uint8_t ucXorSum;
;;;127    	uint8_t ucaBuf[2];
;;;128    	uint16_t i;
;;;129    
;;;130    	if (_usLen < 3)
000002  2903              CMP      r1,#3
000004  d329              BCC      |L2.90|
;;;131    	{
;;;132    		return FALSE;
;;;133    	}
;;;134    
;;;135    	/* 如果没有校验字节，也认为出错 */
;;;136    	if (_ucaBuf[_usLen - 3] != '*')
000006  1844              ADDS     r4,r0,r1
000008  f8142c03          LDRB     r2,[r4,#-3]
00000c  2a2a              CMP      r2,#0x2a
00000e  d124              BNE      |L2.90|
;;;137    	{
;;;138    		return FALSE;
;;;139    	}
;;;140    
;;;141    
;;;142    	/* 不允许出现非ASCII字符 */
;;;143    	for (i = 0; i < _usLen - 3; i++)
000010  2200              MOVS     r2,#0
000012  1ec9              SUBS     r1,r1,#3
000014  e005              B        |L2.34|
                  |L2.22|
;;;144    	{
;;;145    		if ((_ucaBuf[i] & 0x80) || (_ucaBuf[i] == 0))
000016  5c83              LDRB     r3,[r0,r2]
000018  061d              LSLS     r5,r3,#24
00001a  d41e              BMI      |L2.90|
00001c  b1eb              CBZ      r3,|L2.90|
00001e  1c52              ADDS     r2,r2,#1
000020  b292              UXTH     r2,r2                 ;143
                  |L2.34|
000022  428a              CMP      r2,r1                 ;143
000024  dbf7              BLT      |L2.22|
;;;146    		{
;;;147    			return FALSE;
;;;148    		}
;;;149    	}
;;;150    
;;;151    	ucXorSum = _ucaBuf[0];
000026  7802              LDRB     r2,[r0,#0]
000028  f88d2000          STRB     r2,[sp,#0]
;;;152    	for (i = 1; i < _usLen - 3; i++)
00002c  2201              MOVS     r2,#1
00002e  e007              B        |L2.64|
                  |L2.48|
;;;153    	{
;;;154    		ucXorSum = ucXorSum ^ _ucaBuf[i];
000030  5c83              LDRB     r3,[r0,r2]
000032  f89d5000          LDRB     r5,[sp,#0]
000036  406b              EORS     r3,r3,r5
000038  1c52              ADDS     r2,r2,#1
00003a  f88d3000          STRB     r3,[sp,#0]
00003e  b292              UXTH     r2,r2                 ;152
                  |L2.64|
000040  428a              CMP      r2,r1                 ;152
000042  dbf5              BLT      |L2.48|
;;;155    	}
;;;156    
;;;157    	HexToAscii(&ucXorSum, ucaBuf, 2);
000044  2202              MOVS     r2,#2
000046  a901              ADD      r1,sp,#4
000048  4668              MOV      r0,sp
00004a  f7fffffe          BL       HexToAscii
;;;158    
;;;159    	if (memcmp(&_ucaBuf[_usLen - 2], ucaBuf, 2) == 0)
00004e  1ea0              SUBS     r0,r4,#2
000050  2202              MOVS     r2,#2
000052  a901              ADD      r1,sp,#4
000054  f7fffffe          BL       memcmp
000058  b108              CBZ      r0,|L2.94|
                  |L2.90|
;;;160    	{
;;;161    		return TRUE;
;;;162    	}
;;;163    
;;;164    	return FALSE;
00005a  2000              MOVS     r0,#0
;;;165    }
00005c  bd7c              POP      {r2-r6,pc}
                  |L2.94|
00005e  2001              MOVS     r0,#1                 ;161
000060  bd7c              POP      {r2-r6,pc}
;;;166    
                          ENDP


                          AREA ||i.HexToAscii||, CODE, READONLY, ALIGN=1

                  HexToAscii PROC
;;;1119   */
;;;1120   void HexToAscii(uint8_t *_ucpHex, uint8_t *_ucpAscII, uint8_t _ucLenasc)
000000  b530              PUSH     {r4,r5,lr}
;;;1121   {
;;;1122   	uint8_t i;
;;;1123   	uint8_t ucTemp;
;;;1124   
;;;1125   	for (i = 0; i < _ucLenasc; i++)
000002  2400              MOVS     r4,#0
000004  e00f              B        |L3.38|
                  |L3.6|
;;;1126   	{
;;;1127   		ucTemp = *_ucpHex;
000006  7803              LDRB     r3,[r0,#0]
;;;1128   		if ((i&0x01) == 0x00)
000008  07e5              LSLS     r5,r4,#31
00000a  d006              BEQ      |L3.26|
;;;1129   			ucTemp = ucTemp >> 4;
;;;1130   		else
;;;1131   		{
;;;1132   			ucTemp = ucTemp & 0x0f;
00000c  f003030f          AND      r3,r3,#0xf
000010  1c40              ADDS     r0,r0,#1
                  |L3.18|
;;;1133   			_ucpHex++;
;;;1134   		}
;;;1135   		if (ucTemp < 0x0a)
000012  2b0a              CMP      r3,#0xa
000014  d203              BCS      |L3.30|
000016  3330              ADDS     r3,r3,#0x30
;;;1136   			ucTemp += 0x30;
000018  e002              B        |L3.32|
                  |L3.26|
00001a  091b              LSRS     r3,r3,#4              ;1129
00001c  e7f9              B        |L3.18|
                  |L3.30|
00001e  3337              ADDS     r3,r3,#0x37           ;1129
                  |L3.32|
;;;1137   		else
;;;1138   			ucTemp += 0x37;
;;;1139   		_ucpAscII[i] = ucTemp;
000020  550b              STRB     r3,[r1,r4]
000022  1c64              ADDS     r4,r4,#1
000024  b2e4              UXTB     r4,r4                 ;1125
                  |L3.38|
000026  4294              CMP      r4,r2                 ;1125
000028  d3ed              BCC      |L3.6|
;;;1140   	}
;;;1141   	//--------debug--------//
;;;1142   	_ucpAscII[i] = '\0';
00002a  2000              MOVS     r0,#0
00002c  5508              STRB     r0,[r1,r4]
;;;1143   	//--------end----------//
;;;1144   }
00002e  bd30              POP      {r4,r5,pc}
;;;1145   
                          ENDP


                          AREA ||i.StrToInt||, CODE, READONLY, ALIGN=1

                  StrToInt PROC
;;;1007   */
;;;1008   int32_t StrToInt(char *_pStr)
000000  b530              PUSH     {r4,r5,lr}
;;;1009   {
;;;1010   	uint8_t flag;
;;;1011   	char *p;
;;;1012   	uint32_t ulInt;
;;;1013   	uint8_t i;
;;;1014   	uint8_t ucTemp;
;;;1015   
;;;1016   	p = _pStr;
;;;1017   	if (*p == '-')
000002  7801              LDRB     r1,[r0,#0]
000004  292d              CMP      r1,#0x2d
000006  d006              BEQ      |L4.22|
;;;1018   	{
;;;1019   		flag = 1;	/* 负数 */
;;;1020   		p++;
;;;1021   	}
;;;1022   	else
;;;1023   	{
;;;1024   		flag = 0;
000008  2400              MOVS     r4,#0
                  |L4.10|
;;;1025   	}
;;;1026   
;;;1027   	ulInt = 0;
00000a  2200              MOVS     r2,#0
;;;1028   	for (i = 0; i < 15; i++)
00000c  4613              MOV      r3,r2
                  |L4.14|
;;;1029   	{
;;;1030   		ucTemp = *p;
00000e  7801              LDRB     r1,[r0,#0]
;;;1031   		if (ucTemp == '.')	/* 遇到小数点，自动跳过1个字节 */
000010  292e              CMP      r1,#0x2e
000012  d003              BEQ      |L4.28|
000014  e004              B        |L4.32|
                  |L4.22|
000016  2401              MOVS     r4,#1                 ;1019
000018  1c40              ADDS     r0,r0,#1              ;1019
00001a  e7f6              B        |L4.10|
                  |L4.28|
;;;1032   		{
;;;1033   			p++;
;;;1034   			ucTemp = *p;
00001c  f8101f01          LDRB     r1,[r0,#1]!
                  |L4.32|
;;;1035   		}
;;;1036   		if ((ucTemp >= '0') && (ucTemp <= '9'))
000020  f1a10530          SUB      r5,r1,#0x30
000024  2d09              CMP      r5,#9
000026  d809              BHI      |L4.60|
;;;1037   		{
;;;1038   			ulInt = ulInt * 10 + (ucTemp - '0');
000028  eb020282          ADD      r2,r2,r2,LSL #2
00002c  eb010242          ADD      r2,r1,r2,LSL #1
000030  1c5b              ADDS     r3,r3,#1
000032  b2db              UXTB     r3,r3                 ;1028
000034  1c40              ADDS     r0,r0,#1              ;1028
000036  3a30              SUBS     r2,r2,#0x30           ;1028
000038  2b0f              CMP      r3,#0xf               ;1028
;;;1039   			p++;
00003a  d3e8              BCC      |L4.14|
                  |L4.60|
;;;1040   		}
;;;1041   		else
;;;1042   		{
;;;1043   			break;
;;;1044   		}
;;;1045   	}
;;;1046   
;;;1047   	if (flag == 1)
00003c  b10c              CBZ      r4,|L4.66|
;;;1048   	{
;;;1049   		return -ulInt;
00003e  4250              RSBS     r0,r2,#0
;;;1050   	}
;;;1051   	return ulInt;
;;;1052   }
000040  bd30              POP      {r4,r5,pc}
                  |L4.66|
000042  4610              MOV      r0,r2                 ;1051
000044  bd30              POP      {r4,r5,pc}
;;;1053   
                          ENDP


                          AREA ||i.StrToIntFix||, CODE, READONLY, ALIGN=1

                  StrToIntFix PROC
;;;1062   */
;;;1063   int32_t StrToIntFix(char *_pStr, uint8_t _ucLen)
000000  b570              PUSH     {r4-r6,lr}
;;;1064   {
;;;1065   	uint8_t flag;
;;;1066   	char *p;
;;;1067   	uint32_t ulInt;
;;;1068   	uint8_t i;
;;;1069   	uint8_t ucTemp;
;;;1070   
;;;1071   	p = _pStr;
;;;1072   	if (*p == '-')
000002  7802              LDRB     r2,[r0,#0]
000004  2a2d              CMP      r2,#0x2d
000006  d003              BEQ      |L5.16|
;;;1073   	{
;;;1074   		flag = 1;	/* 负数 */
;;;1075   		p++;
;;;1076   		_ucLen--;
;;;1077   	}
;;;1078   	else
;;;1079   	{
;;;1080   		flag = 0;
000008  2500              MOVS     r5,#0
                  |L5.10|
;;;1081   	}
;;;1082   
;;;1083   	ulInt = 0;
00000a  2300              MOVS     r3,#0
;;;1084   	for (i = 0; i < _ucLen; i++)
00000c  461c              MOV      r4,r3
00000e  e015              B        |L5.60|
                  |L5.16|
000010  1e49              SUBS     r1,r1,#1              ;1074
000012  2501              MOVS     r5,#1                 ;1074
000014  b2c9              UXTB     r1,r1                 ;1076
000016  1c40              ADDS     r0,r0,#1              ;1076
000018  e7f7              B        |L5.10|
                  |L5.26|
;;;1085   	{
;;;1086   		ucTemp = *p;
00001a  7802              LDRB     r2,[r0,#0]
;;;1087   		if (ucTemp == '.')	/* 遇到小数点，自动跳过1个字节 */
00001c  2a2e              CMP      r2,#0x2e
00001e  d101              BNE      |L5.36|
;;;1088   		{
;;;1089   			p++;
;;;1090   			ucTemp = *p;
000020  f8102f01          LDRB     r2,[r0,#1]!
                  |L5.36|
;;;1091   		}
;;;1092   		if ((ucTemp >= '0') && (ucTemp <= '9'))
000024  f1a20630          SUB      r6,r2,#0x30
000028  2e09              CMP      r6,#9
00002a  d809              BHI      |L5.64|
;;;1093   		{
;;;1094   			ulInt = ulInt * 10 + (ucTemp - '0');
00002c  eb030383          ADD      r3,r3,r3,LSL #2
000030  1c64              ADDS     r4,r4,#1
000032  eb020343          ADD      r3,r2,r3,LSL #1
000036  1c40              ADDS     r0,r0,#1              ;1084
000038  b2e4              UXTB     r4,r4                 ;1084
00003a  3b30              SUBS     r3,r3,#0x30           ;1084
                  |L5.60|
00003c  428c              CMP      r4,r1                 ;1084
00003e  d3ec              BCC      |L5.26|
                  |L5.64|
;;;1095   			p++;
;;;1096   		}
;;;1097   		else
;;;1098   		{
;;;1099   			break;
;;;1100   		}
;;;1101   	}
;;;1102   
;;;1103   	if (flag == 1)
000040  b10d              CBZ      r5,|L5.70|
;;;1104   	{
;;;1105   		return -ulInt;
000042  4258              RSBS     r0,r3,#0
;;;1106   	}
;;;1107   	return ulInt;
;;;1108   }
000044  bd70              POP      {r4-r6,pc}
                  |L5.70|
000046  4618              MOV      r0,r3                 ;1107
000048  bd70              POP      {r4-r6,pc}
;;;1109   
                          ENDP


                          AREA ||i.UTCDate||, CODE, READONLY, ALIGN=1

                  UTCDate PROC
;;;1212   */
;;;1213   void UTCDate(void)
000000  4770              BX       lr
;;;1214   {
;;;1215   	#if 0
;;;1216   	/* 处理UTC时差 */
;;;1217   	{
;;;1218   		uint8_t ucaDays[]={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
;;;1219   
;;;1220   		if (g_tParam.iUTCtime > 0)
;;;1221   		{
;;;1222   			g_tGPS.Hour += g_tParam.iUTCtime;
;;;1223   			if (g_tGPS.Hour > 23)
;;;1224   			{
;;;1225   				g_tGPS.Hour = g_tGPS.Hour - 24;
;;;1226   				g_tGPS.ucDay++;
;;;1227   
;;;1228   				/* 闰年2月份为29天 */
;;;1229   				if (IsLeapYear(g_tGPS.usYear))
;;;1230   				{
;;;1231   					ucaDays[1] = 29;
;;;1232   				}
;;;1233   				else
;;;1234   				{
;;;1235   					ucaDays[1] = 28;
;;;1236   				}
;;;1237   
;;;1238   				if (g_tGPS.ucDay > ucaDays[g_tGPS.ucMonth - 1])
;;;1239   				{
;;;1240   					g_tGPS.ucDay = 1;
;;;1241   
;;;1242   					g_tGPS.ucMonth++;
;;;1243   
;;;1244   					if (g_tGPS.ucMonth > 12)
;;;1245   					{
;;;1246   						g_tGPS.usYear++;
;;;1247   					}
;;;1248   				}
;;;1249   			}
;;;1250   
;;;1251   		}
;;;1252   		else if (g_tParam.iUTCtime < 0)
;;;1253   		{
;;;1254   			int iHour;
;;;1255   
;;;1256   			iHour = g_tGPS.Hour;
;;;1257   			iHour += g_tParam.iUTCtime;
;;;1258   
;;;1259   			if (iHour < 0)
;;;1260   			{
;;;1261   				g_tGPS.Hour = 24 + iHour;
;;;1262   
;;;1263   				if (g_tGPS.ucDay == 1)
;;;1264   				{
;;;1265   					if (g_tGPS.ucMonth == 1)
;;;1266   					{
;;;1267   						g_tGPS.usYear--;
;;;1268   						g_tGPS.ucMonth = 12;
;;;1269   						g_tGPS.ucDay = 31;
;;;1270   					}
;;;1271   					else
;;;1272   					{
;;;1273   						if (g_tGPS.ucMonth == 3)
;;;1274   						{
;;;1275   							g_tGPS.ucMonth = 2;
;;;1276   
;;;1277   							/* 闰年2月份为29天 */
;;;1278   							if (IsLeapYear(g_tGPS.usYear))
;;;1279   							{
;;;1280   								g_tGPS.ucDay = 29;
;;;1281   							}
;;;1282   							else
;;;1283   							{
;;;1284   								g_tGPS.ucDay = 28;
;;;1285   							}
;;;1286   						}
;;;1287   						else
;;;1288   						{
;;;1289   							g_tGPS.ucMonth--;
;;;1290   
;;;1291   							g_tGPS.ucDay = ucaDays[g_tGPS.ucMonth];
;;;1292   						}
;;;1293   					}
;;;1294   				}
;;;1295   				else
;;;1296   				{
;;;1297   					g_tGPS.ucDay--;
;;;1298   				}
;;;1299   			}
;;;1300   			else
;;;1301   			{
;;;1302   				g_tGPS.Hour = iHour;
;;;1303   			}
;;;1304   		}
;;;1305   	}
;;;1306   	#endif
;;;1307   }
;;;1308   
                          ENDP


                          AREA ||i.bsp_InitGPS||, CODE, READONLY, ALIGN=2

                  bsp_InitGPS PROC
;;;38     */
;;;39     void bsp_InitGPS(void)
000000  4803              LDR      r0,|L7.16|
;;;40     {
;;;41     	/*
;;;42     		GPS 模块使用 UART 串口发送定位数据至 STM32, 每秒钟发送一组数据
;;;43     
;;;44     		因此，只需要配置串口即可。 bsp_uart_fifo.c 中已经配置好串口，此处不必再配置
;;;45     	*/
;;;46     
;;;47     	g_tGPS.PositionOk = 0;  /* 数据设置为无效 */
000002  2100              MOVS     r1,#0
000004  7041              STRB     r1,[r0,#1]
;;;48     	g_tGPS.TimeOk = 0;  /* 数据设置为无效 */
000006  f8801068          STRB     r1,[r0,#0x68]
;;;49     	
;;;50     	g_tGPS.UartOk = 0;	/* 串口通信正常的标志, 如果以后收到了校验合格的命令串则设置为1 */
00000a  7001              STRB     r1,[r0,#0]
;;;51     }
00000c  4770              BX       lr
;;;52     
                          ENDP

00000e  0000              DCW      0x0000
                  |L7.16|
                          DCD      ||.bss||+0x400

                          AREA ||i.gpsGPGGA||, CODE, READONLY, ALIGN=2

                  gpsGPGGA PROC
;;;192    */
;;;193    void gpsGPGGA(uint8_t *_ucaBuf, uint16_t _usLen)
000000  b570              PUSH     {r4-r6,lr}
;;;194    {
;;;195    	char *p;
;;;196    
;;;197    	p = (char *)_ucaBuf;
;;;198    	p[_usLen] = 0;
000002  2600              MOVS     r6,#0
000004  5446              STRB     r6,[r0,r1]
;;;199    
;;;200    	/* 字段1 UTC 时间，hhmmss.sss，时分秒格式 */
;;;201    	p = strchr(p, ',');
000006  212c              MOVS     r1,#0x2c
000008  f7fffffe          BL       strchr
;;;202    	if (p == 0)
00000c  2800              CMP      r0,#0
00000e  d07d              BEQ      |L8.268|
000010  1c40              ADDS     r0,r0,#1
;;;203    	{
;;;204    		return;
;;;205    	}
;;;206    	p++;
000012  4605              MOV      r5,r0
;;;207    	g_tGPS.Hour = StrToIntFix(p, 2);
000014  2102              MOVS     r1,#2
000016  f7fffffe          BL       StrToIntFix
00001a  4c4b              LDR      r4,|L8.328|
;;;208    	p += 2;
;;;209    	g_tGPS.Min = StrToIntFix(p, 2);
00001c  1cad              ADDS     r5,r5,#2
00001e  2102              MOVS     r1,#2
000020  f8040f62          STRB     r0,[r4,#0x62]!        ;207
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       StrToIntFix
00002a  7060              STRB     r0,[r4,#1]
;;;210    	p += 2;
;;;211    	g_tGPS.Sec = StrToIntFix(p, 2);
00002c  1cad              ADDS     r5,r5,#2
00002e  2102              MOVS     r1,#2
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       StrToIntFix
000036  70a0              STRB     r0,[r4,#2]
;;;212    	p += 2;
000038  1ca8              ADDS     r0,r5,#2
;;;213    
;;;214    	/* 字段2 纬度ddmm.mmmm，度分格式（前导位数不足则补0） */
;;;215    	p = strchr(p, ',');
00003a  212c              MOVS     r1,#0x2c
00003c  3c62              SUBS     r4,r4,#0x62
00003e  f7fffffe          BL       strchr
000042  0005              MOVS     r5,r0
;;;216    	if (p == 0)
000044  d07b              BEQ      |L8.318|
;;;217    	{
;;;218    		return;
;;;219    	}
;;;220    	p++;
000046  1c45              ADDS     r5,r0,#1
;;;221    	g_tGPS.WeiDu_Du = StrToIntFix(p, 2);
000048  2102              MOVS     r1,#2
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       StrToIntFix
000050  f8a4004e          STRH     r0,[r4,#0x4e]
;;;222    	p += 2;
;;;223    	g_tGPS.WeiDu_Fen = StrToIntFix(p, 2) * 100000;
000054  1cad              ADDS     r5,r5,#2
000056  2102              MOVS     r1,#2
000058  4628              MOV      r0,r5
00005a  f7fffffe          BL       StrToIntFix
00005e  493b              LDR      r1,|L8.332|
;;;224    	p += 3;
;;;225    	g_tGPS.WeiDu_Fen += StrToIntFix(p, 5);
000060  1ced              ADDS     r5,r5,#3
000062  4348              MULS     r0,r1,r0              ;223
000064  6520              STR      r0,[r4,#0x50]  ; g_tGPS
000066  2105              MOVS     r1,#5
000068  4628              MOV      r0,r5
00006a  f7fffffe          BL       StrToIntFix
00006e  6d21              LDR      r1,[r4,#0x50]  ; g_tGPS
000070  4408              ADD      r0,r0,r1
;;;226    	p += 5;
000072  6520              STR      r0,[r4,#0x50]  ; g_tGPS
000074  1d68              ADDS     r0,r5,#5
;;;227    
;;;228    	/* 字段3 纬度N（北纬）或S（南纬） */
;;;229    	p = strchr(p, ',');
000076  212c              MOVS     r1,#0x2c
000078  f7fffffe          BL       strchr
;;;230    	if (p == 0)
00007c  2800              CMP      r0,#0
00007e  d05e              BEQ      |L8.318|
;;;231    	{
;;;232    		return;
;;;233    	}
;;;234    	p++;
;;;235    	if (*p == 'S')
000080  f8101f01          LDRB     r1,[r0,#1]!
000084  2953              CMP      r1,#0x53
000086  d001              BEQ      |L8.140|
;;;236    	{
;;;237    		g_tGPS.NS = 'S';
;;;238    	}
;;;239    	else if (*p == 'N')
000088  294e              CMP      r1,#0x4e
00008a  d158              BNE      |L8.318|
                  |L8.140|
;;;240    	{
;;;241    		g_tGPS.NS = 'N';
00008c  f8841054          STRB     r1,[r4,#0x54]
;;;242    	}
;;;243    	else
;;;244    	{
;;;245    		return;
;;;246    	}
;;;247    
;;;248    	/* 字段4  经度dddmm.mmmm，度分格式（前导位数不足则补0） */
;;;249    	p = strchr(p, ',');
000090  212c              MOVS     r1,#0x2c
000092  f7fffffe          BL       strchr
;;;250    	if (p == 0)
000096  2800              CMP      r0,#0
000098  d051              BEQ      |L8.318|
00009a  1c40              ADDS     r0,r0,#1
;;;251    	{
;;;252    		return;
;;;253    	}
;;;254    	p++;
00009c  4605              MOV      r5,r0
;;;255    	g_tGPS.JingDu_Du = StrToIntFix(p, 3);
00009e  2103              MOVS     r1,#3
0000a0  f7fffffe          BL       StrToIntFix
0000a4  f8a40056          STRH     r0,[r4,#0x56]
;;;256    	p += 3;
;;;257    	g_tGPS.JingDu_Fen = StrToIntFix(p, 2) * 100000;
0000a8  1ced              ADDS     r5,r5,#3
0000aa  2102              MOVS     r1,#2
0000ac  4628              MOV      r0,r5
0000ae  f7fffffe          BL       StrToIntFix
0000b2  4926              LDR      r1,|L8.332|
;;;258    	p += 3;
;;;259    	g_tGPS.JingDu_Fen += StrToIntFix(p, 5);
0000b4  1ced              ADDS     r5,r5,#3
0000b6  4348              MULS     r0,r1,r0              ;257
0000b8  65a0              STR      r0,[r4,#0x58]  ; g_tGPS
0000ba  2105              MOVS     r1,#5
0000bc  4628              MOV      r0,r5
0000be  f7fffffe          BL       StrToIntFix
0000c2  6da1              LDR      r1,[r4,#0x58]  ; g_tGPS
0000c4  4408              ADD      r0,r0,r1
;;;260    	p += 5;
0000c6  65a0              STR      r0,[r4,#0x58]  ; g_tGPS
0000c8  1d68              ADDS     r0,r5,#5
;;;261    
;;;262    	/* 字段5 经度E（东经）或W（西经） */
;;;263    	p = strchr(p, ',');
0000ca  212c              MOVS     r1,#0x2c
0000cc  f7fffffe          BL       strchr
;;;264    	if (p == 0)
0000d0  2800              CMP      r0,#0
0000d2  d034              BEQ      |L8.318|
;;;265    	{
;;;266    		return;
;;;267    	}
;;;268    	p++;
;;;269    	if (*p == 'E')
0000d4  f8101f01          LDRB     r1,[r0,#1]!
0000d8  2945              CMP      r1,#0x45
0000da  d001              BEQ      |L8.224|
;;;270    	{
;;;271    		g_tGPS.EW = 'E';
;;;272    	}
;;;273    	else if (*p == 'W')
0000dc  2957              CMP      r1,#0x57
0000de  d101              BNE      |L8.228|
                  |L8.224|
;;;274    	{
;;;275    		g_tGPS.EW = 'W';
0000e0  f884105c          STRB     r1,[r4,#0x5c]
                  |L8.228|
;;;276    	}
;;;277    
;;;278    	/* 字段6 GPS状态，0=未定位，1=非差分定位，2=差分定位，3=无效PPS，6=正在估算 */
;;;279    	p = strchr(p, ',');
0000e4  212c              MOVS     r1,#0x2c
0000e6  f7fffffe          BL       strchr
;;;280    	if (p == 0)
0000ea  2800              CMP      r0,#0
0000ec  d027              BEQ      |L8.318|
;;;281    	{
;;;282    		return;
;;;283    	}
;;;284    	p++;
;;;285    	if ((*p == '1') || (*p == '2'))
0000ee  f8101f01          LDRB     r1,[r0,#1]!
0000f2  2931              CMP      r1,#0x31
0000f4  d024              BEQ      |L8.320|
0000f6  2932              CMP      r1,#0x32
0000f8  d022              BEQ      |L8.320|
;;;286    	{
;;;287    		g_tGPS.PositionOk = 1;
;;;288    	}
;;;289    	else
;;;290    	{
;;;291    		g_tGPS.PositionOk = 0;
0000fa  7066              STRB     r6,[r4,#1]
                  |L8.252|
;;;292    	}
;;;293    
;;;294    	/* 字段7：正在使用的卫星数量（00 - 12）（前导位数不足则补0） */
;;;295    	p = strchr(p, ',');
0000fc  212c              MOVS     r1,#0x2c
0000fe  f7fffffe          BL       strchr
;;;296    	if (p == 0)
000102  2800              CMP      r0,#0
000104  d01b              BEQ      |L8.318|
000106  1c40              ADDS     r0,r0,#1
;;;297    	{
;;;298    		return;
;;;299    	}
;;;300    	p++;
000108  4605              MOV      r5,r0
;;;301    	g_tGPS.ViewNumber = StrToInt(p);
00010a  e000              B        |L8.270|
                  |L8.268|
00010c  e017              B        |L8.318|
                  |L8.270|
00010e  f7fffffe          BL       StrToInt
000112  7720              STRB     r0,[r4,#0x1c]
;;;302    	p += 2;
000114  1ca8              ADDS     r0,r5,#2
;;;303    
;;;304    	/* 字段8：HDOP水平精度因子（0.5 - 99.9） */
;;;305    	p = strchr(p, ',');
000116  212c              MOVS     r1,#0x2c
000118  f7fffffe          BL       strchr
;;;306    	if (p == 0)
00011c  2800              CMP      r0,#0
00011e  d00e              BEQ      |L8.318|
000120  1c40              ADDS     r0,r0,#1
;;;307    	{
;;;308    		return;
;;;309    	}
;;;310    	p++;
000122  4605              MOV      r5,r0
;;;311    	g_tGPS.HDOP = StrToInt(p);
000124  f7fffffe          BL       StrToInt
000128  8320              STRH     r0,[r4,#0x18]
;;;312    
;;;313    	/* 字段9：海拔高度（-9999.9 - 99999.9） */
;;;314    	p = strchr(p, ',');
00012a  212c              MOVS     r1,#0x2c
00012c  4628              MOV      r0,r5
00012e  f7fffffe          BL       strchr
;;;315    	if (p == 0)
000132  2800              CMP      r0,#0
000134  d003              BEQ      |L8.318|
000136  1c40              ADDS     r0,r0,#1
;;;316    	{
;;;317    		return;
;;;318    	}
;;;319    	p++;
;;;320    	g_tGPS.Altitude = StrToInt(p);
000138  f7fffffe          BL       StrToInt
;;;321    
;;;322    	/* 后面的字段信息丢弃 */
;;;323    }
00013c  6060              STR      r0,[r4,#4]  ; g_tGPS
                  |L8.318|
00013e  bd70              POP      {r4-r6,pc}
                  |L8.320|
000140  2101              MOVS     r1,#1                 ;287
000142  7061              STRB     r1,[r4,#1]            ;287
000144  e7da              B        |L8.252|
;;;324    
                          ENDP

000146  0000              DCW      0x0000
                  |L8.328|
                          DCD      ||.bss||+0x400
                  |L8.332|
                          DCD      0x000186a0

                          AREA ||i.gpsGPGLL||, CODE, READONLY, ALIGN=2

                  gpsGPGLL PROC
;;;806    */
;;;807    void gpsGPGLL(uint8_t *_ucaBuf, uint16_t _usLen)
000000  b570              PUSH     {r4-r6,lr}
;;;808    {
;;;809    	char *p;
;;;810    
;;;811    	p = (char *)_ucaBuf;
;;;812    	p[_usLen] = 0;
000002  2200              MOVS     r2,#0
000004  5442              STRB     r2,[r0,r1]
;;;813    
;;;814    	/* 字段1 纬度ddmm.mmmm，度分格式（前导位数不足则补0） */
;;;815    	p = strchr(p, ',');
000006  212c              MOVS     r1,#0x2c
000008  f7fffffe          BL       strchr
;;;816    	if (p == 0)
00000c  2800              CMP      r0,#0
00000e  d06b              BEQ      |L9.232|
000010  1c40              ADDS     r0,r0,#1
;;;817    	{
;;;818    		return;
;;;819    	}
;;;820    	p++;
000012  4605              MOV      r5,r0
;;;821    	g_tGPS.WeiDu_Du = StrToIntFix(p, 2);
000014  2102              MOVS     r1,#2
000016  f7fffffe          BL       StrToIntFix
00001a  4c34              LDR      r4,|L9.236|
;;;822    	p += 2;
;;;823    	g_tGPS.WeiDu_Fen = StrToIntFix(p, 2) * 100000;
00001c  1cad              ADDS     r5,r5,#2
00001e  2102              MOVS     r1,#2
000020  f8a4004e          STRH     r0,[r4,#0x4e]         ;821
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       StrToIntFix
00002a  4931              LDR      r1,|L9.240|
;;;824    	p += 3;
;;;825    	g_tGPS.WeiDu_Fen += StrToIntFix(p, 5);
00002c  1ced              ADDS     r5,r5,#3
00002e  4348              MULS     r0,r1,r0              ;823
000030  6520              STR      r0,[r4,#0x50]  ; g_tGPS
000032  2105              MOVS     r1,#5
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       StrToIntFix
00003a  6d21              LDR      r1,[r4,#0x50]  ; g_tGPS
00003c  4408              ADD      r0,r0,r1
;;;826    	p += 5;
00003e  6520              STR      r0,[r4,#0x50]  ; g_tGPS
000040  1d68              ADDS     r0,r5,#5
;;;827    
;;;828    	/* 字段2 纬度N（北纬）或S（南纬）*/
;;;829    	p = strchr(p, ',');
000042  212c              MOVS     r1,#0x2c
000044  f7fffffe          BL       strchr
;;;830    	if (p == 0)
000048  2800              CMP      r0,#0
00004a  d04d              BEQ      |L9.232|
;;;831    	{
;;;832    		return;
;;;833    	}
;;;834    	p++;
;;;835    	if (*p == 'S')
00004c  f8101f01          LDRB     r1,[r0,#1]!
000050  2953              CMP      r1,#0x53
000052  d001              BEQ      |L9.88|
;;;836    	{
;;;837    		g_tGPS.NS = 'S';
;;;838    	}
;;;839    	else if (*p == 'N')
000054  294e              CMP      r1,#0x4e
000056  d147              BNE      |L9.232|
                  |L9.88|
;;;840    	{
;;;841    		g_tGPS.NS = 'N';
000058  f8841054          STRB     r1,[r4,#0x54]
;;;842    	}
;;;843    	else
;;;844    	{
;;;845    		return;
;;;846    	}
;;;847    
;;;848    	/* 字段3 经度dddmm.mmmm，度分格式（前导位数不足则补0） */
;;;849    	p = strchr(p, ',');
00005c  212c              MOVS     r1,#0x2c
00005e  f7fffffe          BL       strchr
;;;850    	if (p == 0)
000062  2800              CMP      r0,#0
000064  d040              BEQ      |L9.232|
;;;851    	{
;;;852    		return;
;;;853    	}
;;;854    	p++;
000066  1c45              ADDS     r5,r0,#1
;;;855    	g_tGPS.JingDu_Du = StrToIntFix(p, 3);
000068  2103              MOVS     r1,#3
00006a  4628              MOV      r0,r5
00006c  f7fffffe          BL       StrToIntFix
000070  f8a40056          STRH     r0,[r4,#0x56]
;;;856    	p += 3;
;;;857    	g_tGPS.JingDu_Fen = StrToIntFix(p, 2) * 100000;
000074  1ced              ADDS     r5,r5,#3
000076  2102              MOVS     r1,#2
000078  4628              MOV      r0,r5
00007a  f7fffffe          BL       StrToIntFix
00007e  491c              LDR      r1,|L9.240|
;;;858    	p += 3;
;;;859    	g_tGPS.JingDu_Fen += StrToIntFix(p, 5);
000080  1ced              ADDS     r5,r5,#3
000082  4348              MULS     r0,r1,r0              ;857
000084  65a0              STR      r0,[r4,#0x58]  ; g_tGPS
000086  2105              MOVS     r1,#5
000088  4628              MOV      r0,r5
00008a  f7fffffe          BL       StrToIntFix
00008e  6da1              LDR      r1,[r4,#0x58]  ; g_tGPS
000090  4408              ADD      r0,r0,r1
;;;860    	p += 5;
000092  65a0              STR      r0,[r4,#0x58]  ; g_tGPS
000094  1d68              ADDS     r0,r5,#5
;;;861    
;;;862    	/* 字段4：经度E（东经）或W（西经） */
;;;863    	p = strchr(p, ',');
000096  212c              MOVS     r1,#0x2c
000098  f7fffffe          BL       strchr
;;;864    	if (p == 0)
00009c  2800              CMP      r0,#0
00009e  d023              BEQ      |L9.232|
;;;865    	{
;;;866    		return;
;;;867    	}
;;;868    	p++;
;;;869    	if (*p == 'E')
0000a0  f8101f01          LDRB     r1,[r0,#1]!
0000a4  2945              CMP      r1,#0x45
0000a6  d001              BEQ      |L9.172|
;;;870    	{
;;;871    		g_tGPS.EW = 'E';
;;;872    	}
;;;873    	else if (*p == 'W')
0000a8  2957              CMP      r1,#0x57
0000aa  d101              BNE      |L9.176|
                  |L9.172|
;;;874    	{
;;;875    		g_tGPS.EW = 'W';
0000ac  f884105c          STRB     r1,[r4,#0x5c]
                  |L9.176|
;;;876    	}
;;;877    
;;;878    	/* 字段5 UTC时间，hhmmss.sss格式 */
;;;879    	p = strchr(p, ',');
0000b0  212c              MOVS     r1,#0x2c
0000b2  f7fffffe          BL       strchr
;;;880    	if (p == 0)
0000b6  2800              CMP      r0,#0
0000b8  d016              BEQ      |L9.232|
;;;881    	{
;;;882    		return;
;;;883    	}
;;;884    	p++;
0000ba  1c45              ADDS     r5,r0,#1
;;;885    	g_tGPS.Hour = StrToIntFix(p, 2);
0000bc  2102              MOVS     r1,#2
0000be  4628              MOV      r0,r5
0000c0  f7fffffe          BL       StrToIntFix
0000c4  f8040f62          STRB     r0,[r4,#0x62]!
;;;886    	p += 2;
;;;887    	g_tGPS.Min = StrToIntFix(p, 2);
0000c8  1cad              ADDS     r5,r5,#2
0000ca  2102              MOVS     r1,#2
0000cc  4628              MOV      r0,r5
0000ce  f7fffffe          BL       StrToIntFix
0000d2  7060              STRB     r0,[r4,#1]
;;;888    	p += 2;
;;;889    	g_tGPS.Sec = StrToIntFix(p, 2);
0000d4  1cad              ADDS     r5,r5,#2
0000d6  2102              MOVS     r1,#2
0000d8  4628              MOV      r0,r5
0000da  f7fffffe          BL       StrToIntFix
0000de  70a0              STRB     r0,[r4,#2]
;;;890    	p += 2;
0000e0  1ca8              ADDS     r0,r5,#2
;;;891    
;;;892    	/* 字段6 状态，A=定位，V=未定位 */
;;;893    	p = strchr(p, ',');
0000e2  212c              MOVS     r1,#0x2c
0000e4  f7fffffe          BL       strchr
                  |L9.232|
;;;894    	if (p == 0)
;;;895    	{
;;;896    		return;
;;;897    	}
;;;898    	p++;
;;;899    	if (*p != 'A')
;;;900    	{
;;;901    		/* 未定位则直接返回 */
;;;902    		return;
;;;903    	}
;;;904    }
0000e8  bd70              POP      {r4-r6,pc}
;;;905    
                          ENDP

0000ea  0000              DCW      0x0000
                  |L9.236|
                          DCD      ||.bss||+0x400
                  |L9.240|
                          DCD      0x000186a0

                          AREA ||i.gpsGPGSA||, CODE, READONLY, ALIGN=2

                  gpsGPGSA PROC
;;;355    */
;;;356    void gpsGPGSA(uint8_t *_ucaBuf, uint16_t _usLen)
000000  b570              PUSH     {r4-r6,lr}
;;;357    {
;;;358    	char *p;
;;;359    	uint8_t i;
;;;360    
;;;361    	p = (char *)_ucaBuf;
;;;362    	p[_usLen] = 0;
000002  2200              MOVS     r2,#0
000004  5442              STRB     r2,[r0,r1]
;;;363    
;;;364    	/* 字段1 定位模式，A=自动手动2D/3D，M=手动2D/3D */
;;;365    	p = strchr(p, ',');
000006  212c              MOVS     r1,#0x2c
000008  f7fffffe          BL       strchr
;;;366    	if (p == 0)
00000c  2800              CMP      r0,#0
00000e  d03c              BEQ      |L10.138|
;;;367    	{
;;;368    		return;
;;;369    	}
;;;370    	p++;
;;;371    	g_tGPS.ModeAM = *p;
000010  4c1e              LDR      r4,|L10.140|
000012  f8101f01          LDRB     r1,[r0,#1]!
000016  7221              STRB     r1,[r4,#8]
;;;372    
;;;373    	/* 字段2 定位类型，1=未定位，2=2D定位，3=3D定位 */
;;;374    	p = strchr(p, ',');
000018  212c              MOVS     r1,#0x2c
00001a  f7fffffe          BL       strchr
;;;375    	if (p == 0)
00001e  2800              CMP      r0,#0
000020  d033              BEQ      |L10.138|
;;;376    	{
;;;377    		return;
;;;378    	}
;;;379    	p++;
000022  1c45              ADDS     r5,r0,#1
;;;380    	g_tGPS.Mode2D3D = *p;
000024  7840              LDRB     r0,[r0,#1]
000026  7260              STRB     r0,[r4,#9]
;;;381    
;;;382    	/* 字段3 - 字段14 第1-12信道正在使用的卫星PRN码编号 */
;;;383    	for (i = 0; i < 12; i++)
000028  2600              MOVS     r6,#0
                  |L10.42|
;;;384    	{
;;;385    		p = strchr(p, ',');
00002a  212c              MOVS     r1,#0x2c
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       strchr
;;;386    		if (p == 0)
000032  2800              CMP      r0,#0
000034  d029              BEQ      |L10.138|
000036  1c40              ADDS     r0,r0,#1
;;;387    		{
;;;388    			return;
;;;389    		}
;;;390    		p++;
000038  4605              MOV      r5,r0
;;;391    		g_tGPS.SateID[i] = StrToInt(p);
00003a  f7fffffe          BL       StrToInt
00003e  19a1              ADDS     r1,r4,r6
000040  1c76              ADDS     r6,r6,#1
000042  b2f6              UXTB     r6,r6                 ;383
000044  7288              STRB     r0,[r1,#0xa]
000046  2e0c              CMP      r6,#0xc               ;383
000048  d3ef              BCC      |L10.42|
;;;392    	}
;;;393    
;;;394    	/* 字段15：PDOP综合位置精度因子（0.5 - 99.9） */
;;;395    	p = strchr(p, ',');
00004a  212c              MOVS     r1,#0x2c
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       strchr
;;;396    	if (p == 0)
000052  2800              CMP      r0,#0
000054  d019              BEQ      |L10.138|
000056  1c40              ADDS     r0,r0,#1
;;;397    	{
;;;398    		return;
;;;399    	}
;;;400    	p++;
000058  4605              MOV      r5,r0
;;;401    	g_tGPS.PDOP = StrToInt(p);
00005a  f7fffffe          BL       StrToInt
00005e  82e0              STRH     r0,[r4,#0x16]
;;;402    
;;;403    	/* 字段16：HDOP水平精度因子（0.5 - 99.9） */
;;;404    	p = strchr(p, ',');
000060  212c              MOVS     r1,#0x2c
000062  4628              MOV      r0,r5
000064  f7fffffe          BL       strchr
;;;405    	if (p == 0)
000068  2800              CMP      r0,#0
00006a  d00e              BEQ      |L10.138|
00006c  1c40              ADDS     r0,r0,#1
;;;406    	{
;;;407    		return;
;;;408    	}
;;;409    	p++;
00006e  4605              MOV      r5,r0
;;;410    	g_tGPS.HDOP = StrToInt(p);
000070  f7fffffe          BL       StrToInt
000074  8320              STRH     r0,[r4,#0x18]
;;;411    
;;;412    	/* 字段17：VDOP垂直精度因子（0.5 - 99.9） */
;;;413    	p = strchr(p, ',');
000076  212c              MOVS     r1,#0x2c
000078  4628              MOV      r0,r5
00007a  f7fffffe          BL       strchr
;;;414    	if (p == 0)
00007e  2800              CMP      r0,#0
000080  d003              BEQ      |L10.138|
000082  1c40              ADDS     r0,r0,#1
;;;415    	{
;;;416    		return;
;;;417    	}
;;;418    	p++;
;;;419    	g_tGPS.VDOP = StrToInt(p);
000084  f7fffffe          BL       StrToInt
000088  8360              STRH     r0,[r4,#0x1a]
                  |L10.138|
;;;420    }
00008a  bd70              POP      {r4-r6,pc}
;;;421    
                          ENDP

                  |L10.140|
                          DCD      ||.bss||+0x400

                          AREA ||i.gpsGPGSV||, CODE, READONLY, ALIGN=2

                  gpsGPGSV PROC
;;;457    */
;;;458    void gpsGPGSV(uint8_t *_ucaBuf, uint16_t _usLen)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;459    {
;;;460    //	uint8_t s_total = 0;	/* 语句总数目 */
;;;461    	uint8_t s_no = 0;		/* 语句序号 */
;;;462    	uint8_t i;
;;;463    	char *p;
;;;464    
;;;465    	p = (char *)_ucaBuf;
;;;466    	p[_usLen] = 0;
000004  2200              MOVS     r2,#0
000006  5442              STRB     r2,[r0,r1]
;;;467    
;;;468    	/* 字段1：本次GSV语句的总数目（1 - 3） */
;;;469    	p = strchr(p, ',');
000008  212c              MOVS     r1,#0x2c
00000a  f7fffffe          BL       strchr
;;;470    	if (p == 0)
00000e  2800              CMP      r0,#0
000010  d052              BEQ      |L11.184|
;;;471    	{
;;;472    		return;
;;;473    	}
;;;474    	p++;
;;;475    //	s_total = StrToInt(p);
;;;476    
;;;477    	/* 字段2：本条GSV语句是本次GSV语句的第几条（1 - 3） */
;;;478    	p = strchr(p, ',');
000012  212c              MOVS     r1,#0x2c
000014  1c40              ADDS     r0,r0,#1
000016  f7fffffe          BL       strchr
;;;479    	if (p == 0)
00001a  2800              CMP      r0,#0
00001c  d04c              BEQ      |L11.184|
;;;480    	{
;;;481    		return;
;;;482    	}
;;;483    	p++;
00001e  1c44              ADDS     r4,r0,#1
;;;484    	s_no = StrToInt(p);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       StrToInt
000026  b2c7              UXTB     r7,r0
;;;485    
;;;486    	/* 字段3：当前可见卫星总数（00 - 12）（前导位数不足则补0） */
;;;487    	p = strchr(p, ',');
000028  212c              MOVS     r1,#0x2c
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       strchr
;;;488    	if (p == 0)
000030  2800              CMP      r0,#0
000032  d041              BEQ      |L11.184|
000034  1c40              ADDS     r0,r0,#1
;;;489    	{
;;;490    		return;
;;;491    	}
;;;492    	p++;
000036  4605              MOV      r5,r0
;;;493    	g_tGPS.ViewNumber = StrToInt(p);
000038  f7fffffe          BL       StrToInt
00003c  4e1f              LDR      r6,|L11.188|
;;;494    
;;;495    	for (i = 0; i < 4; i++)
00003e  2400              MOVS     r4,#0
000040  7730              STRB     r0,[r6,#0x1c]         ;493
                  |L11.66|
;;;496    	{
;;;497    		/* 字段4：PRN 码（伪随机噪声码）（01 - 32）（前导位数不足则补0） */
;;;498    		p = strchr(p, ',');
000042  212c              MOVS     r1,#0x2c
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       strchr
;;;499    		if (p == 0)
00004a  2800              CMP      r0,#0
00004c  d034              BEQ      |L11.184|
;;;500    		{
;;;501    			return;
;;;502    		}
;;;503    		p++;
00004e  1c45              ADDS     r5,r0,#1
;;;504    		g_tGPS.SateID[(s_no - 1) * 4 + i] = StrToInt(p);
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       StrToInt
000056  00b9              LSLS     r1,r7,#2
000058  1f09              SUBS     r1,r1,#4
00005a  eb010904          ADD      r9,r1,r4
00005e  eb090806          ADD      r8,r9,r6
;;;505    
;;;506    		/* 字段5：卫星仰角（00 - 90）度（前导位数不足则补0）*/
;;;507    		p = strchr(p, ',');
000062  212c              MOVS     r1,#0x2c
000064  f888000a          STRB     r0,[r8,#0xa]          ;504
000068  4628              MOV      r0,r5
00006a  f7fffffe          BL       strchr
;;;508    		if (p == 0)
00006e  2800              CMP      r0,#0
000070  d022              BEQ      |L11.184|
000072  1c40              ADDS     r0,r0,#1
;;;509    		{
;;;510    			return;
;;;511    		}
;;;512    		p++;
000074  4605              MOV      r5,r0
;;;513    		g_tGPS.Elevation[(s_no - 1) * 4 + i] = StrToInt(p);
000076  f7fffffe          BL       StrToInt
00007a  f888001d          STRB     r0,[r8,#0x1d]
;;;514    
;;;515    		/* 字段6：卫星方位角（00 - 359）度（前导位数不足则补0） */
;;;516    		p = strchr(p, ',');
00007e  212c              MOVS     r1,#0x2c
000080  4628              MOV      r0,r5
000082  f7fffffe          BL       strchr
;;;517    		if (p == 0)
000086  2800              CMP      r0,#0
000088  d016              BEQ      |L11.184|
00008a  1c40              ADDS     r0,r0,#1
;;;518    		{
;;;519    			return;
;;;520    		}
;;;521    		p++;
00008c  4605              MOV      r5,r0
;;;522    		g_tGPS.Azimuth[(s_no - 1) * 4 + i] = StrToInt(p);
00008e  f7fffffe          BL       StrToInt
000092  eb060149          ADD      r1,r6,r9,LSL #1
000096  8548              STRH     r0,[r1,#0x2a]
;;;523    
;;;524    		/* 字段7：信噪比（00－99）dbHz */
;;;525    		p = strchr(p, ',');
000098  212c              MOVS     r1,#0x2c
00009a  4628              MOV      r0,r5
00009c  f7fffffe          BL       strchr
;;;526    		if (p == 0)
0000a0  2800              CMP      r0,#0
0000a2  d009              BEQ      |L11.184|
0000a4  1c40              ADDS     r0,r0,#1
;;;527    		{
;;;528    			return;
;;;529    		}
;;;530    		p++;
0000a6  4605              MOV      r5,r0
;;;531    		g_tGPS.SNR[(s_no - 1) * 4 + i] = StrToInt(p);
0000a8  f7fffffe          BL       StrToInt
0000ac  1c64              ADDS     r4,r4,#1
0000ae  b2e4              UXTB     r4,r4                 ;495
0000b0  f8880042          STRB     r0,[r8,#0x42]
0000b4  2c04              CMP      r4,#4                 ;495
0000b6  d3c4              BCC      |L11.66|
                  |L11.184|
;;;532    	}
;;;533    }
0000b8  e8bd87f0          POP      {r4-r10,pc}
;;;534    
                          ENDP

                  |L11.188|
                          DCD      ||.bss||+0x400

                          AREA ||i.gpsGPRMC||, CODE, READONLY, ALIGN=2

                  gpsGPRMC PROC
;;;559    */
;;;560    void gpsGPRMC(uint8_t *_ucaBuf, uint16_t _usLen)
000000  b570              PUSH     {r4-r6,lr}
;;;561    {
;;;562    	char *p;
;;;563    
;;;564    	p = (char *)_ucaBuf;
;;;565    	p[_usLen] = 0;
000002  2600              MOVS     r6,#0
000004  5446              STRB     r6,[r0,r1]
;;;566    
;;;567    	/* 字段1 UTC时间，hhmmss.sss格式 */
;;;568    	p = strchr(p, ',');
000006  212c              MOVS     r1,#0x2c
000008  f7fffffe          BL       strchr
;;;569    	if (p == 0)
00000c  2800              CMP      r0,#0
00000e  d025              BEQ      |L12.92|
000010  1c40              ADDS     r0,r0,#1
;;;570    	{
;;;571    		return;
;;;572    	}
;;;573    	p++;
000012  4605              MOV      r5,r0
;;;574    	g_tGPS.Hour = StrToIntFix(p, 2);
000014  2102              MOVS     r1,#2
000016  f7fffffe          BL       StrToIntFix
00001a  4c54              LDR      r4,|L12.364|
;;;575    	p += 2;
;;;576    	g_tGPS.Min = StrToIntFix(p, 2);
00001c  1cad              ADDS     r5,r5,#2
00001e  2102              MOVS     r1,#2
000020  f8040f62          STRB     r0,[r4,#0x62]!        ;574
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       StrToIntFix
00002a  7060              STRB     r0,[r4,#1]
;;;577    	p += 2;
;;;578    	g_tGPS.Sec = StrToIntFix(p, 2);
00002c  1cad              ADDS     r5,r5,#2
00002e  2102              MOVS     r1,#2
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       StrToIntFix
000036  70a0              STRB     r0,[r4,#2]
;;;579    	p += 3;
;;;580    	g_tGPS.mSec = StrToIntFix(p, 3);
000038  1ced              ADDS     r5,r5,#3
00003a  2103              MOVS     r1,#3
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       StrToIntFix
000042  80a0              STRH     r0,[r4,#4]
;;;581    
;;;582    	/* 字段2 状态，A=定位，V=未定位 */
;;;583    	p = strchr(p, ',');
000044  212c              MOVS     r1,#0x2c
000046  4628              MOV      r0,r5
000048  3c62              SUBS     r4,r4,#0x62
00004a  f7fffffe          BL       strchr
;;;584    	if (p == 0)
00004e  2800              CMP      r0,#0
000050  d004              BEQ      |L12.92|
;;;585    	{
;;;586    		return;
;;;587    	}
;;;588    	p++;
;;;589    	if (*p != 'A')
000052  f8101f01          LDRB     r1,[r0,#1]!
000056  2941              CMP      r1,#0x41
000058  d001              BEQ      |L12.94|
;;;590    	{
;;;591    		/* 未定位则直接返回 */
;;;592    		g_tGPS.PositionOk = 0;
00005a  7066              STRB     r6,[r4,#1]
                  |L12.92|
;;;593    		return;
;;;594    	}
;;;595    	g_tGPS.PositionOk = 1;
;;;596    	p += 1;
;;;597    
;;;598    	/* 字段3 纬度ddmm.mmmm，度分格式（前导位数不足则补0） */
;;;599    	p = strchr(p, ',');
;;;600    	if (p == 0)
;;;601    	{
;;;602    		return;
;;;603    	}
;;;604    	p++;
;;;605    	g_tGPS.WeiDu_Du = StrToIntFix(p, 2);
;;;606    	p += 2;
;;;607    	g_tGPS.WeiDu_Fen = StrToIntFix(p, 2) * 100000;
;;;608    	p += 3;
;;;609    	g_tGPS.WeiDu_Fen += StrToIntFix(p, 5);
;;;610    	p += 5;
;;;611    
;;;612    	/* 字段4 纬度N（北纬）或S（南纬）*/
;;;613    	p = strchr(p, ',');
;;;614    	if (p == 0)
;;;615    	{
;;;616    		return;
;;;617    	}
;;;618    	p++;
;;;619    	if (*p == 'S')
;;;620    	{
;;;621    		g_tGPS.NS = 'S';
;;;622    	}
;;;623    	else if (*p == 'N')
;;;624    	{
;;;625    		g_tGPS.NS = 'N';
;;;626    	}
;;;627    	else
;;;628    	{
;;;629    		return;
;;;630    	}
;;;631    
;;;632    	/* 字段5 经度dddmm.mmmm，度分格式（前导位数不足则补0） */
;;;633    	p = strchr(p, ',');
;;;634    	if (p == 0)
;;;635    	{
;;;636    		return;
;;;637    	}
;;;638    	p++;
;;;639    	g_tGPS.JingDu_Du = StrToIntFix(p, 3);
;;;640    	p += 3;
;;;641    	g_tGPS.JingDu_Fen = StrToIntFix(p, 2) * 100000;
;;;642    	p += 3;
;;;643    	g_tGPS.JingDu_Fen += StrToIntFix(p, 5);
;;;644    	p += 5;
;;;645    
;;;646    	/* 字段6：经度E（东经）或W（西经） */
;;;647    	p = strchr(p, ',');
;;;648    	if (p == 0)
;;;649    	{
;;;650    		return;
;;;651    	}
;;;652    	p++;
;;;653    	if (*p == 'E')
;;;654    	{
;;;655    		g_tGPS.EW = 'E';
;;;656    	}
;;;657    	else if (*p == 'W')
;;;658    	{
;;;659    		g_tGPS.EW = 'W';
;;;660    	}
;;;661    
;;;662    	/* 字段7：速度，节，Knots  10.05,*/
;;;663    	p = strchr(p, ',');
;;;664    	if (p == 0)
;;;665    	{
;;;666    		return;
;;;667    	}
;;;668    	p++;
;;;669    	g_tGPS.SpeedKnots = StrToInt(p);
;;;670    
;;;671    	/* 字段8：方位角，度 ,324.27 */
;;;672    	p = strchr(p, ',');
;;;673    	if (p == 0)
;;;674    	{
;;;675    		return;
;;;676    	}
;;;677    	p++;
;;;678    	g_tGPS.TrackDegTrue = StrToInt(p);
;;;679    
;;;680    	/* 字段9：UTC日期，DDMMYY格式  150706 */
;;;681    	p = strchr(p, ',');
;;;682    	if (p == 0)
;;;683    	{
;;;684    		return;
;;;685    	}
;;;686    	p++;
;;;687    	g_tGPS.Day = StrToIntFix(p, 2);
;;;688    	p += 2;
;;;689    	g_tGPS.Month = StrToIntFix(p, 2);
;;;690    	p += 2;
;;;691    	g_tGPS.Year = StrToIntFix(p, 2);
;;;692    	p += 2;
;;;693    }
00005c  bd70              POP      {r4-r6,pc}
                  |L12.94|
00005e  2101              MOVS     r1,#1                 ;595
000060  7061              STRB     r1,[r4,#1]            ;595
000062  212c              MOVS     r1,#0x2c              ;599
000064  1c40              ADDS     r0,r0,#1              ;599
000066  f7fffffe          BL       strchr
00006a  2800              CMP      r0,#0                 ;600
00006c  d0f6              BEQ      |L12.92|
00006e  1c40              ADDS     r0,r0,#1              ;600
000070  4605              MOV      r5,r0                 ;604
000072  2102              MOVS     r1,#2                 ;605
000074  f7fffffe          BL       StrToIntFix
000078  f8a4004e          STRH     r0,[r4,#0x4e]         ;605
00007c  1cad              ADDS     r5,r5,#2              ;607
00007e  2102              MOVS     r1,#2                 ;607
000080  4628              MOV      r0,r5                 ;607
000082  f7fffffe          BL       StrToIntFix
000086  493a              LDR      r1,|L12.368|
000088  1ced              ADDS     r5,r5,#3              ;609
00008a  4348              MULS     r0,r1,r0              ;607
00008c  6520              STR      r0,[r4,#0x50]         ;609  ; g_tGPS
00008e  2105              MOVS     r1,#5                 ;609
000090  4628              MOV      r0,r5                 ;609
000092  f7fffffe          BL       StrToIntFix
000096  6d21              LDR      r1,[r4,#0x50]         ;609  ; g_tGPS
000098  4408              ADD      r0,r0,r1              ;609
00009a  6520              STR      r0,[r4,#0x50]         ;610  ; g_tGPS
00009c  1d68              ADDS     r0,r5,#5              ;610
00009e  212c              MOVS     r1,#0x2c              ;613
0000a0  f7fffffe          BL       strchr
0000a4  2800              CMP      r0,#0                 ;614
0000a6  d0d9              BEQ      |L12.92|
0000a8  f8101f01          LDRB     r1,[r0,#1]!           ;619
0000ac  2953              CMP      r1,#0x53              ;619
0000ae  d001              BEQ      |L12.180|
0000b0  294e              CMP      r1,#0x4e              ;623
0000b2  d1d3              BNE      |L12.92|
                  |L12.180|
0000b4  f8841054          STRB     r1,[r4,#0x54]         ;625
0000b8  212c              MOVS     r1,#0x2c              ;633
0000ba  f7fffffe          BL       strchr
0000be  2800              CMP      r0,#0                 ;634
0000c0  d0cc              BEQ      |L12.92|
0000c2  1c40              ADDS     r0,r0,#1              ;634
0000c4  4605              MOV      r5,r0                 ;638
0000c6  2103              MOVS     r1,#3                 ;639
0000c8  f7fffffe          BL       StrToIntFix
0000cc  f8a40056          STRH     r0,[r4,#0x56]         ;639
0000d0  1ced              ADDS     r5,r5,#3              ;641
0000d2  2102              MOVS     r1,#2                 ;641
0000d4  4628              MOV      r0,r5                 ;641
0000d6  f7fffffe          BL       StrToIntFix
0000da  4925              LDR      r1,|L12.368|
0000dc  1ced              ADDS     r5,r5,#3              ;643
0000de  4348              MULS     r0,r1,r0              ;641
0000e0  65a0              STR      r0,[r4,#0x58]         ;643  ; g_tGPS
0000e2  2105              MOVS     r1,#5                 ;643
0000e4  4628              MOV      r0,r5                 ;643
0000e6  f7fffffe          BL       StrToIntFix
0000ea  6da1              LDR      r1,[r4,#0x58]         ;643  ; g_tGPS
0000ec  4408              ADD      r0,r0,r1              ;643
0000ee  65a0              STR      r0,[r4,#0x58]         ;644  ; g_tGPS
0000f0  1d68              ADDS     r0,r5,#5              ;644
0000f2  212c              MOVS     r1,#0x2c              ;647
0000f4  f7fffffe          BL       strchr
0000f8  2800              CMP      r0,#0                 ;648
0000fa  d0af              BEQ      |L12.92|
0000fc  f8101f01          LDRB     r1,[r0,#1]!           ;653
000100  2945              CMP      r1,#0x45              ;653
000102  d001              BEQ      |L12.264|
000104  2957              CMP      r1,#0x57              ;657
000106  d101              BNE      |L12.268|
                  |L12.264|
000108  f884105c          STRB     r1,[r4,#0x5c]         ;659
                  |L12.268|
00010c  212c              MOVS     r1,#0x2c              ;663
00010e  f7fffffe          BL       strchr
000112  2800              CMP      r0,#0                 ;664
000114  d0a2              BEQ      |L12.92|
000116  1c40              ADDS     r0,r0,#1              ;664
000118  4605              MOV      r5,r0                 ;668
00011a  f7fffffe          BL       StrToInt
00011e  6720              STR      r0,[r4,#0x70]         ;672  ; g_tGPS
000120  212c              MOVS     r1,#0x2c              ;672
000122  4628              MOV      r0,r5                 ;672
000124  f7fffffe          BL       strchr
000128  2800              CMP      r0,#0                 ;673
00012a  d097              BEQ      |L12.92|
00012c  1c40              ADDS     r0,r0,#1              ;673
00012e  4605              MOV      r5,r0                 ;677
000130  f7fffffe          BL       StrToInt
000134  f8a4006a          STRH     r0,[r4,#0x6a]         ;678
000138  212c              MOVS     r1,#0x2c              ;681
00013a  4628              MOV      r0,r5                 ;681
00013c  f7fffffe          BL       strchr
000140  2800              CMP      r0,#0                 ;682
000142  d08b              BEQ      |L12.92|
000144  1c45              ADDS     r5,r0,#1              ;686
000146  2102              MOVS     r1,#2                 ;687
000148  4628              MOV      r0,r5                 ;687
00014a  f7fffffe          BL       StrToIntFix
00014e  f8840061          STRB     r0,[r4,#0x61]         ;687
000152  1cad              ADDS     r5,r5,#2              ;689
000154  2102              MOVS     r1,#2                 ;689
000156  4628              MOV      r0,r5                 ;689
000158  345e              ADDS     r4,r4,#0x5e           ;689
00015a  f7fffffe          BL       StrToIntFix
00015e  70a0              STRB     r0,[r4,#2]            ;689
000160  1ca8              ADDS     r0,r5,#2              ;690
000162  2102              MOVS     r1,#2                 ;691
000164  f7fffffe          BL       StrToIntFix
000168  8020              STRH     r0,[r4,#0]            ;691
00016a  bd70              POP      {r4-r6,pc}
;;;694    
                          ENDP

                  |L12.364|
                          DCD      ||.bss||+0x400
                  |L12.368|
                          DCD      0x000186a0

                          AREA ||i.gpsGPVTG||, CODE, READONLY, ALIGN=2

                  gpsGPVTG PROC
;;;716    */
;;;717    void gpsGPVTG(uint8_t *_ucaBuf, uint16_t _usLen)
000000  b570              PUSH     {r4-r6,lr}
;;;718    {
;;;719    	char *p;
;;;720    
;;;721    	p = (char *)_ucaBuf;
;;;722    	p[_usLen] = 0;
000002  2200              MOVS     r2,#0
000004  5442              STRB     r2,[r0,r1]
;;;723    
;;;724    	/* 字段1：运动角度，000 - 359，（前导位数不足则补0）*/
;;;725    	p = strchr(p, ',');
000006  212c              MOVS     r1,#0x2c
000008  f7fffffe          BL       strchr
;;;726    	if (p == 0)
00000c  2800              CMP      r0,#0
00000e  d039              BEQ      |L13.132|
000010  1c40              ADDS     r0,r0,#1
;;;727    	{
;;;728    		return;
;;;729    	}
;;;730    	p++;
000012  4605              MOV      r5,r0
;;;731    	g_tGPS.TrackDegTrue = StrToInt(p);
000014  f7fffffe          BL       StrToInt
000018  4c1b              LDR      r4,|L13.136|
;;;732    
;;;733    	/* 字段2：T=真北参照系 */
;;;734    	p = strchr(p, ',');
00001a  212c              MOVS     r1,#0x2c
00001c  f8a4006a          STRH     r0,[r4,#0x6a]         ;731
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       strchr
;;;735    	if (p == 0)
000026  2800              CMP      r0,#0
000028  d02c              BEQ      |L13.132|
;;;736    	{
;;;737    		return;
;;;738    	}
;;;739    	p++;
;;;740    
;;;741    	/* 字段3：运动角度，000 - 359，（前导位数不足则补0） */
;;;742    	p = strchr(p, ',');
00002a  212c              MOVS     r1,#0x2c
00002c  1c40              ADDS     r0,r0,#1
00002e  f7fffffe          BL       strchr
;;;743    	if (p == 0)
000032  2800              CMP      r0,#0
000034  d026              BEQ      |L13.132|
000036  1c40              ADDS     r0,r0,#1
;;;744    	{
;;;745    		return;
;;;746    	}
;;;747    	p++;
000038  4605              MOV      r5,r0
;;;748    	g_tGPS.TrackDegMag = StrToInt(p);
00003a  f7fffffe          BL       StrToInt
00003e  f8a4006c          STRH     r0,[r4,#0x6c]
;;;749    
;;;750    	/* 字段4：M=磁北参照系 */
;;;751    	p = strchr(p, ',');
000042  212c              MOVS     r1,#0x2c
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       strchr
;;;752    	if (p == 0)
00004a  2800              CMP      r0,#0
00004c  d01a              BEQ      |L13.132|
;;;753    	{
;;;754    		return;
;;;755    	}
;;;756    	p++;
;;;757    
;;;758    	/* 字段5：地面速率（000.0~999.9节，前面的0也将被传输） */
;;;759    	p = strchr(p, ',');
00004e  212c              MOVS     r1,#0x2c
000050  1c40              ADDS     r0,r0,#1
000052  f7fffffe          BL       strchr
;;;760    	if (p == 0)
000056  2800              CMP      r0,#0
000058  d014              BEQ      |L13.132|
00005a  1c40              ADDS     r0,r0,#1
;;;761    	{
;;;762    		return;
;;;763    	}
;;;764    	p++;
00005c  4605              MOV      r5,r0
;;;765    	g_tGPS.SpeedKnots = StrToInt(p);
00005e  f7fffffe          BL       StrToInt
;;;766    
;;;767    	/* 字段6：N=节，Knots */
;;;768    	p = strchr(p, ',');
000062  6720              STR      r0,[r4,#0x70]  ; g_tGPS
000064  212c              MOVS     r1,#0x2c
000066  4628              MOV      r0,r5
000068  f7fffffe          BL       strchr
;;;769    	if (p == 0)
00006c  2800              CMP      r0,#0
00006e  d009              BEQ      |L13.132|
;;;770    	{
;;;771    		return;
;;;772    	}
;;;773    	p++;
;;;774    
;;;775    	/* 字段7：地面速率（0000.0~1851.8公里/小时，前面的0也将被传输） */
;;;776    	p = strchr(p, ',');
000070  212c              MOVS     r1,#0x2c
000072  1c40              ADDS     r0,r0,#1
000074  f7fffffe          BL       strchr
;;;777    	if (p == 0)
000078  2800              CMP      r0,#0
00007a  d003              BEQ      |L13.132|
00007c  1c40              ADDS     r0,r0,#1
;;;778    	{
;;;779    		return;
;;;780    	}
;;;781    	p++;
;;;782    	g_tGPS.SpeedKM = StrToInt(p);
00007e  f7fffffe          BL       StrToInt
000082  6760              STR      r0,[r4,#0x74]  ; g_tGPS
                  |L13.132|
;;;783    
;;;784    	/* 字段8：K=公里/时，km/h	 */
;;;785    }
000084  bd70              POP      {r4-r6,pc}
;;;786    
                          ENDP

000086  0000              DCW      0x0000
                  |L13.136|
                          DCD      ||.bss||+0x400

                          AREA ||i.gps_FenToDu||, CODE, READONLY, ALIGN=1

                  gps_FenToDu PROC
;;;1153   */
;;;1154   uint32_t gps_FenToDu(uint32_t _fen)
000000  2164              MOVS     r1,#0x64
;;;1155   {
;;;1156   	uint32_t du;
;;;1157   	
;;;1158   	/* g_tGPS.WeiDu_Fen;	纬度，分. 232475；  小数点后4位  表示 23.2475分 */
;;;1159   	
;;;1160   	du = (_fen * 100) / 60;
000002  4348              MULS     r0,r1,r0
000004  213c              MOVS     r1,#0x3c
000006  fbb0f0f1          UDIV     r0,r0,r1
;;;1161   	
;;;1162   	return du;
;;;1163   }
00000a  4770              BX       lr
;;;1164   
                          ENDP


                          AREA ||i.gps_FenToMiao||, CODE, READONLY, ALIGN=1

                  gps_FenToMiao PROC
;;;1172   */
;;;1173   uint16_t gps_FenToMiao(uint32_t _fen)
000000  f2427110          MOV      r1,#0x2710
;;;1174   {
;;;1175   	uint32_t miao;
;;;1176   	
;;;1177   	/* g_tGPS.WeiDu_Fen;	纬度，分. 232475；  小数点后4位  表示 23.2475分 
;;;1178   		其中小数部分 0.2475 * 60 = 14.85 四舍五入为 15秒	
;;;1179   		
;;;1180   		
;;;1181   		2475 * 60 = 148500
;;;1182   		148500 / 10000 = 14;
;;;1183   		
;;;1184   		if ((148500 % 10000) >= 5000)
;;;1185   		{
;;;1186   			miao = 14 + 1
;;;1187   		}
;;;1188   	*/
;;;1189   	
;;;1190   	miao = ((_fen % 10000) * 60);
000004  fbb0f2f1          UDIV     r2,r0,r1
000008  fb010012          MLS      r0,r1,r2,r0
00000c  ebc01000          RSB      r0,r0,r0,LSL #4
000010  0080              LSLS     r0,r0,#2
;;;1191   	
;;;1192   	if ((miao % 10000) >= 5000)
000012  fbb0f2f1          UDIV     r2,r0,r1
000016  fb010212          MLS      r2,r1,r2,r0
;;;1193   	{
;;;1194   		miao = miao / 10000 + 1;	/* 5入 */
;;;1195   	}
;;;1196   	else
;;;1197   	{
;;;1198   		miao = miao / 10000;		/* 4舍 */
00001a  fbb0f0f1          UDIV     r0,r0,r1
00001e  104b              ASRS     r3,r1,#1              ;1192
000020  429a              CMP      r2,r3                 ;1192
000022  d300              BCC      |L15.38|
000024  1c40              ADDS     r0,r0,#1              ;1174
                  |L15.38|
;;;1199   	}
;;;1200   		
;;;1201   	return miao;
000026  b280              UXTH     r0,r0
;;;1202   }
000028  4770              BX       lr
;;;1203   
                          ENDP


                          AREA ||i.gps_pro||, CODE, READONLY, ALIGN=2

                  gps_pro PROC
;;;60     */
;;;61     void gps_pro(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;62     {
;;;63     	uint8_t ucData;
;;;64     	static uint8_t ucGpsHead = 0;
;;;65     	static uint8_t ucaGpsBuf[1024];
;;;66     	static uint16_t usGpsPos = 0;
;;;67     
;;;68     	/* 从 GPS模块串口读取1个字节 comGetChar() 函数由 bsp_uart_fifo.c 实现 */
;;;69     	while (1)
;;;70     	{
;;;71     		if (comGetChar(COM2, &ucData))
000002  2601              MOVS     r6,#1
;;;72     		{
;;;73     			#ifdef DEBUG_GPS_TO_COM1
;;;74     				/* 将收到的GPS模块数据按原样 打印到COM1 口，便于跟踪调试 */
;;;75     				comSendChar(COM1, ucData);
;;;76     			#endif
;;;77     
;;;78     			if (ucGpsHead == 0)
000004  4c18              LDR      r4,|L16.104|
000006  2500              MOVS     r5,#0                 ;71
                  |L16.8|
000008  4669              MOV      r1,sp                 ;71
00000a  2001              MOVS     r0,#1                 ;71
00000c  f7fffffe          BL       comGetChar
000010  2800              CMP      r0,#0                 ;71
000012  d027              BEQ      |L16.100|
000014  f89d1000          LDRB     r1,[sp,#0]            ;75
000018  2000              MOVS     r0,#0                 ;75
00001a  f7fffffe          BL       comSendChar
00001e  7820              LDRB     r0,[r4,#0]  ; ucGpsHead
000020  b1b8              CBZ      r0,|L16.82|
;;;79     			{
;;;80     				if (ucData == '$')
;;;81     				{
;;;82     					ucGpsHead = 1;
;;;83     					usGpsPos = 0;
;;;84     				}
;;;85     			}
;;;86     			else
;;;87     			{
;;;88     				if (usGpsPos < sizeof(ucaGpsBuf))
000022  8860              LDRH     r0,[r4,#2]  ; usGpsPos
000024  f5b06f80          CMP      r0,#0x400
000028  d21a              BCS      |L16.96|
;;;89     				{
;;;90     					ucaGpsBuf[usGpsPos++] = ucData;
00002a  4a10              LDR      r2,|L16.108|
00002c  f89d1000          LDRB     r1,[sp,#0]
000030  5411              STRB     r1,[r2,r0]
000032  1c40              ADDS     r0,r0,#1
000034  b280              UXTH     r0,r0
000036  8060              STRH     r0,[r4,#2]
;;;91     
;;;92     					if ((ucData == '\r') || (ucData == '\n'))
000038  290d              CMP      r1,#0xd
00003a  d001              BEQ      |L16.64|
00003c  290a              CMP      r1,#0xa
00003e  d1e3              BNE      |L16.8|
                  |L16.64|
000040  1e40              SUBS     r0,r0,#1
;;;93     					{
;;;94     						Analyze0183(ucaGpsBuf, usGpsPos-1);
000042  b281              UXTH     r1,r0
000044  4809              LDR      r0,|L16.108|
000046  f7fffffe          BL       Analyze0183
;;;95     						ucGpsHead = 0;
;;;96     						
;;;97     						g_tGPS.UartOk = 1;	/* 接收到正确的命令 */
00004a  4809              LDR      r0,|L16.112|
00004c  7025              STRB     r5,[r4,#0]            ;95
00004e  7006              STRB     r6,[r0,#0]
000050  e7da              B        |L16.8|
                  |L16.82|
000052  f89d0000          LDRB     r0,[sp,#0]            ;80
000056  2824              CMP      r0,#0x24              ;80
000058  d1d6              BNE      |L16.8|
00005a  7026              STRB     r6,[r4,#0]            ;82
00005c  8065              STRH     r5,[r4,#2]            ;83
00005e  e7d3              B        |L16.8|
                  |L16.96|
;;;98     					}
;;;99     				}
;;;100    				else
;;;101    				{
;;;102    					ucGpsHead = 0;
000060  7025              STRB     r5,[r4,#0]
000062  e7d1              B        |L16.8|
                  |L16.100|
;;;103    				}
;;;104    
;;;105    			}
;;;106    
;;;107    			continue;	/* 可能还有数据，继续分析 */
;;;108    		}
;;;109    
;;;110    		break;	/* 分析完毕，退出函数 */
;;;111    	}
;;;112    }
000064  bdf8              POP      {r3-r7,pc}
;;;113    
                          ENDP

000066  0000              DCW      0x0000
                  |L16.104|
                          DCD      ||.data||
                  |L16.108|
                          DCD      ||.bss||
                  |L16.112|
                          DCD      ||.bss||+0x400

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ucaGpsBuf
                          %        1024
                  g_tGPS
                          %        120

                          AREA ||.data||, DATA, ALIGN=1

                  ucGpsHead
000000  0000              DCB      0x00,0x00
                  usGpsPos
000002  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_gps.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_gps_c_acfa3819____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_bsp_gps_c_acfa3819____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_gps_c_acfa3819____REVSH|
#line 128
|__asm___9_bsp_gps_c_acfa3819____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
