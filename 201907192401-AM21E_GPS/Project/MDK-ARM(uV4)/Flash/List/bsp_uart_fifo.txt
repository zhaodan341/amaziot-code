; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\flash\obj\bsp_uart_fifo.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_uart_fifo.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\bsp_uart_fifo.crf ..\..\User\bsp\src\bsp_uart_fifo.c]
                          THUMB

                          AREA ||i.ComToUart||, CODE, READONLY, ALIGN=2

                  ComToUart PROC
;;;81     */
;;;82     UART_T *ComToUart(COM_PORT_E _ucPort)
000000  b118              CBZ      r0,|L1.10|
;;;83     {
;;;84     	if (_ucPort == COM1)
;;;85     	{
;;;86     		#if UART1_FIFO_EN == 1
;;;87     			return &g_tUart1;
;;;88     		#else
;;;89     			return 0;
;;;90     		#endif
;;;91     	}
;;;92     	else if (_ucPort == COM2)
000002  2801              CMP      r0,#1
000004  d003              BEQ      |L1.14|
;;;93     	{
;;;94     		#if UART2_FIFO_EN == 1
;;;95     			return &g_tUart2;
;;;96     		#else
;;;97     			return;
;;;98     		#endif
;;;99     	}
;;;100    	else if (_ucPort == COM3)
;;;101    	{
;;;102    		#if UART3_FIFO_EN == 1
;;;103    			return &g_tUart3;
;;;104    		#else
;;;105    			return 0;
;;;106    		#endif
;;;107    	}
;;;108    	else if (_ucPort == COM4)
;;;109    	{
;;;110    		#if UART4_FIFO_EN == 1
;;;111    			return &g_tUart4;
;;;112    		#else
;;;113    			return 0;
;;;114    		#endif
;;;115    	}
;;;116    	else if (_ucPort == COM5)
;;;117    	{
;;;118    		#if UART5_FIFO_EN == 1
;;;119    			return &g_tUart5;
;;;120    		#else
;;;121    			return 0;
;;;122    		#endif
;;;123    	}
;;;124    	else
;;;125    	{
;;;126    		/* 不做任何处理 */
;;;127    		return 0;
000006  2000              MOVS     r0,#0
;;;128    	}
;;;129    }
000008  4770              BX       lr
                  |L1.10|
00000a  4802              LDR      r0,|L1.20|
00000c  4770              BX       lr
                  |L1.14|
00000e  4802              LDR      r0,|L1.24|
000010  4770              BX       lr
;;;130    
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      ||.bss||
                  |L1.24|
                          DCD      ||.bss||+0x828

                          AREA ||i.InitHardUart||, CODE, READONLY, ALIGN=2

                  InitHardUart PROC
;;;368    */
;;;369    static void InitHardUart(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;370    {
000004  b085              SUB      sp,sp,#0x14
;;;371    	GPIO_InitTypeDef GPIO_InitStructure;
;;;372    	USART_InitTypeDef USART_InitStructure;
;;;373    
;;;374    #if UART1_FIFO_EN == 1		/* 串口1 TX = PA9   RX = PA10 或 TX = PB6   RX = PB7*/
;;;375    
;;;376    	/* 第1步：打开GPIO和USART部件的时钟 */
;;;377    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
000006  2101              MOVS     r1,#1
000008  2005              MOVS     r0,#5
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;378    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
00000e  2101              MOVS     r1,#1
000010  0388              LSLS     r0,r1,#14
000012  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;379    
;;;380    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;381    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000016  f44f7000          MOV      r0,#0x200
00001a  f8ad0010          STRH     r0,[sp,#0x10]
;;;382    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00001e  2618              MOVS     r6,#0x18
000020  f88d6013          STRB     r6,[sp,#0x13]
;;;383    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000024  2703              MOVS     r7,#3
000026  f88d7012          STRB     r7,[sp,#0x12]
;;;384    	GPIO_Init(GPIOA, &GPIO_InitStructure);
00002a  a904              ADD      r1,sp,#0x10
00002c  4839              LDR      r0,|L2.276|
00002e  f7fffffe          BL       GPIO_Init
;;;385    
;;;386    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;387    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;388    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;389    	*/
;;;390    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000032  f44f6080          MOV      r0,#0x400
000036  f8ad0010          STRH     r0,[sp,#0x10]
;;;391    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00003a  2504              MOVS     r5,#4
00003c  f88d5013          STRB     r5,[sp,#0x13]
;;;392    	GPIO_Init(GPIOA, &GPIO_InitStructure);
000040  a904              ADD      r1,sp,#0x10
000042  4834              LDR      r0,|L2.276|
000044  f7fffffe          BL       GPIO_Init
;;;393    	
;;;394    	/* 第4步： 配置串口硬件参数 */
;;;395    	USART_InitStructure.USART_BaudRate = UART1_BAUD;	/* 波特率 */
;;;396    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000048  2400              MOVS     r4,#0
;;;397    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;398    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;399    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;400    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;401    	USART_Init(USART1, &USART_InitStructure);
00004a  f8dfa0cc          LDR      r10,|L2.280|
00004e  f44f5816          MOV      r8,#0x2580            ;395
000052  f8ad4004          STRH     r4,[sp,#4]            ;396
000056  f8ad4008          STRH     r4,[sp,#8]            ;398
00005a  f04f090c          MOV      r9,#0xc               ;400
00005e  f8cd8000          STR      r8,[sp,#0]            ;396
000062  f8ad4006          STRH     r4,[sp,#6]            ;397
000066  f8ad400c          STRH     r4,[sp,#0xc]          ;399
00006a  f8ad900a          STRH     r9,[sp,#0xa]          ;400
00006e  4669              MOV      r1,sp
000070  4650              MOV      r0,r10
000072  f7fffffe          BL       USART_Init
;;;402    
;;;403    	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
000076  f2405b25          MOV      r11,#0x525
00007a  2201              MOVS     r2,#1
00007c  4659              MOV      r1,r11
00007e  4650              MOV      r0,r10
000080  f7fffffe          BL       USART_ITConfig
;;;404    	/*
;;;405    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;406    		注意: 不要在此处打开发送中断
;;;407    		发送中断使能在SendUart()函数打开
;;;408    	*/
;;;409    	USART_Cmd(USART1, ENABLE);		/* 使能串口 */
000084  2101              MOVS     r1,#1
000086  4650              MOV      r0,r10
000088  f7fffffe          BL       USART_Cmd
;;;410    
;;;411    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;412    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;413    	USART_ClearFlag(USART1, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
00008c  2140              MOVS     r1,#0x40
00008e  4650              MOV      r0,r10
000090  f7fffffe          BL       USART_ClearFlag
;;;414    #endif
;;;415    
;;;416    #if UART2_FIFO_EN == 1		/* 串口2 TX = PA2， RX = PA3  */
;;;417    	/* 第1步：打开GPIO和USART部件的时钟 */
;;;418    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
000094  2101              MOVS     r1,#1
000096  2005              MOVS     r0,#5
000098  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;419    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
00009c  2101              MOVS     r1,#1
00009e  0448              LSLS     r0,r1,#17
0000a0  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;420    
;;;421    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;422    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
0000a4  f8ad5010          STRH     r5,[sp,#0x10]
;;;423    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
0000a8  f88d6013          STRB     r6,[sp,#0x13]
;;;424    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000ac  f88d7012          STRB     r7,[sp,#0x12]
;;;425    	GPIO_Init(GPIOA, &GPIO_InitStructure);
0000b0  a904              ADD      r1,sp,#0x10
0000b2  4818              LDR      r0,|L2.276|
0000b4  f7fffffe          BL       GPIO_Init
;;;426    
;;;427    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;428    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;429    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;430    	*/
;;;431    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
0000b8  2008              MOVS     r0,#8
0000ba  f8ad0010          STRH     r0,[sp,#0x10]
;;;432    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
0000be  f88d5013          STRB     r5,[sp,#0x13]
;;;433    	GPIO_Init(GPIOA, &GPIO_InitStructure);
0000c2  a904              ADD      r1,sp,#0x10
0000c4  4813              LDR      r0,|L2.276|
0000c6  f7fffffe          BL       GPIO_Init
;;;434    	/*  第3步已经做了，因此这步可以不做
;;;435    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;436    	*/
;;;437    	GPIO_Init(GPIOA, &GPIO_InitStructure);
0000ca  a904              ADD      r1,sp,#0x10
0000cc  4811              LDR      r0,|L2.276|
0000ce  f7fffffe          BL       GPIO_Init
;;;438    
;;;439    	/* 第4步： 配置串口硬件参数 */
;;;440    	USART_InitStructure.USART_BaudRate = UART2_BAUD;	/* 波特率 */
;;;441    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
0000d2  f8ad4004          STRH     r4,[sp,#4]
;;;442    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
0000d6  f8ad4006          STRH     r4,[sp,#6]
;;;443    	USART_InitStructure.USART_Parity = USART_Parity_No ;
0000da  f8ad4008          STRH     r4,[sp,#8]
;;;444    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
0000de  f8ad400c          STRH     r4,[sp,#0xc]
;;;445    	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;		/* 仅选择接收模式 */
;;;446    	USART_Init(USART2, &USART_InitStructure);
0000e2  4c0e              LDR      r4,|L2.284|
0000e4  f8cd8000          STR      r8,[sp,#0]            ;441
0000e8  f8ad900a          STRH     r9,[sp,#0xa]          ;445
0000ec  4669              MOV      r1,sp
0000ee  4620              MOV      r0,r4
0000f0  f7fffffe          BL       USART_Init
;;;447    
;;;448    	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
0000f4  2201              MOVS     r2,#1
0000f6  4659              MOV      r1,r11
0000f8  4620              MOV      r0,r4
0000fa  f7fffffe          BL       USART_ITConfig
;;;449    	/*
;;;450    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;451    		注意: 不要在此处打开发送中断
;;;452    		发送中断使能在SendUart()函数打开
;;;453    	*/
;;;454    	USART_Cmd(USART2, ENABLE);		/* 使能串口 */
0000fe  2101              MOVS     r1,#1
000100  4620              MOV      r0,r4
000102  f7fffffe          BL       USART_Cmd
;;;455    
;;;456    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;457    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;458    	USART_ClearFlag(USART2, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
000106  2140              MOVS     r1,#0x40
000108  4620              MOV      r0,r4
00010a  f7fffffe          BL       USART_ClearFlag
;;;459    #endif
;;;460    
;;;461    #if UART3_FIFO_EN == 1			/* 串口3 TX = PB10   RX = PB11 */
;;;462    
;;;463    	/* 配置 PB2为推挽输出，用于切换 RS485芯片的收发状态 */
;;;464    	{
;;;465    		RCC_APB2PeriphClockCmd(RCC_RS485_TXEN, ENABLE);
;;;466    
;;;467    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
;;;468    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;469    		GPIO_InitStructure.GPIO_Pin = PIN_RS485_TXEN;
;;;470    		GPIO_Init(PORT_RS485_TXEN, &GPIO_InitStructure);
;;;471    	}
;;;472    
;;;473    	/* 第1步： 开启GPIO和UART时钟 */
;;;474    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE);
;;;475    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
;;;476    
;;;477    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;478    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
;;;479    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;480    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;481    	GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;482    
;;;483    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;484    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;485    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;486    	*/
;;;487    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
;;;488    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;489    	GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;490    	/*  第3步已经做了，因此这步可以不做
;;;491    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;492    	*/
;;;493    	GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;494    
;;;495    	/* 第4步： 配置串口硬件参数 */
;;;496    	USART_InitStructure.USART_BaudRate = UART3_BAUD;	/* 波特率 */
;;;497    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;498    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;499    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;500    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;501    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;502    	USART_Init(USART3, &USART_InitStructure);
;;;503    
;;;504    	USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;505    	/*
;;;506    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;507    		注意: 不要在此处打开发送中断
;;;508    		发送中断使能在SendUart()函数打开
;;;509    	*/
;;;510    	USART_Cmd(USART3, ENABLE);		/* 使能串口 */
;;;511    
;;;512    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;513    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;514    	USART_ClearFlag(USART3, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;515    #endif
;;;516    
;;;517    #if UART4_FIFO_EN == 1			/* 串口4 TX = PC10   RX = PC11 */
;;;518    	/* 第1步： 开启GPIO和UART时钟 */
;;;519    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO, ENABLE);
;;;520    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
;;;521    
;;;522    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;523    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
;;;524    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;525    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;526    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;527    
;;;528    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;529    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;530    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;531    	*/
;;;532    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
;;;533    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;534    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;535    
;;;536    	/* 第4步： 配置串口硬件参数 */
;;;537    	USART_InitStructure.USART_BaudRate = UART4_BAUD;	/* 波特率 */
;;;538    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;539    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;540    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;541    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;542    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;543    	USART_Init(UART4, &USART_InitStructure);
;;;544    
;;;545    	USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;546    	/*
;;;547    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;548    		注意: 不要在此处打开发送中断
;;;549    		发送中断使能在SendUart()函数打开
;;;550    	*/
;;;551    	USART_Cmd(UART4, ENABLE);		/* 使能串口 */
;;;552    
;;;553    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;554    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;555    	USART_ClearFlag(UART4, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;556    #endif
;;;557    
;;;558    #if UART5_FIFO_EN == 1			/* 串口5 TX = PC12   RX = PD2 */
;;;559    	/* 第1步： 开启GPIO和UART时钟 */
;;;560    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD | RCC_APB2Periph_AFIO, ENABLE);
;;;561    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE);
;;;562    
;;;563    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;564    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
;;;565    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;566    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;567    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;568    
;;;569    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;570    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;571    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;572    	*/
;;;573    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
;;;574    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;575    	GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;576    
;;;577    
;;;578    	/* 第4步： 配置串口硬件参数 */
;;;579    	USART_InitStructure.USART_BaudRate = UART5_BAUD;	/* 波特率 */
;;;580    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;581    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;582    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;583    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;584    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;585    	USART_Init(UART5, &USART_InitStructure);
;;;586    
;;;587    	USART_ITConfig(UART5, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;588    	/*
;;;589    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;590    		注意: 不要在此处打开发送中断
;;;591    		发送中断使能在SendUart()函数打开
;;;592    	*/
;;;593    	USART_Cmd(UART5, ENABLE);		/* 使能串口 */
;;;594    
;;;595    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;596    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;597    	USART_ClearFlag(UART5, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;598    #endif
;;;599    }
00010e  b005              ADD      sp,sp,#0x14
000110  e8bd8ff0          POP      {r4-r11,pc}
;;;600    
                          ENDP

                  |L2.276|
                          DCD      0x40010800
                  |L2.280|
                          DCD      0x40013800
                  |L2.284|
                          DCD      0x40004400

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;876    #if UART1_FIFO_EN == 1
;;;877    void USART1_IRQHandler(void)
000000  4801              LDR      r0,|L3.8|
;;;878    {
;;;879    	UartIRQ(&g_tUart1);
000002  f7ffbffe          B.W      UartIRQ
;;;880    }
;;;881    #endif
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      ||.bss||

                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;883    #if UART2_FIFO_EN == 1
;;;884    void USART2_IRQHandler(void)
000000  4801              LDR      r0,|L4.8|
;;;885    {
;;;886    	UartIRQ(&g_tUart2);
000002  f7ffbffe          B.W      UartIRQ
;;;887    }
;;;888    #endif
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      ||.bss||+0x828

                          AREA ||i.UartIRQ||, CODE, READONLY, ALIGN=1

                  UartIRQ PROC
;;;783    */
;;;784    static void UartIRQ(UART_T *_pUart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;785    {
000004  4604              MOV      r4,r0
;;;786    	/* 处理接收中断  */
;;;787    	if (USART_GetITStatus(_pUart->uart, USART_IT_RXNE) != RESET)
000006  6800              LDR      r0,[r0,#0]
000008  f2405125          MOV      r1,#0x525
00000c  f7fffffe          BL       USART_GetITStatus
000010  2500              MOVS     r5,#0
000012  b1b8              CBZ      r0,|L5.68|
;;;788    	{
;;;789    		/* 从串口接收数据寄存器读取数据存放到接收FIFO */
;;;790    		uint8_t ch;
;;;791    
;;;792    		ch = USART_ReceiveData(_pUart->uart);
000014  6820              LDR      r0,[r4,#0]
000016  f7fffffe          BL       USART_ReceiveData
;;;793    		_pUart->pRxBuf[_pUart->usRxWrite] = ch;
00001a  8ae2              LDRH     r2,[r4,#0x16]
00001c  68a1              LDR      r1,[r4,#8]
00001e  b2c0              UXTB     r0,r0                 ;792
000020  5488              STRB     r0,[r1,r2]
;;;794    		if (++_pUart->usRxWrite >= _pUart->usRxBufSize)
000022  8ae1              LDRH     r1,[r4,#0x16]
000024  1c49              ADDS     r1,r1,#1
000026  b28a              UXTH     r2,r1
000028  82e2              STRH     r2,[r4,#0x16]
00002a  89e1              LDRH     r1,[r4,#0xe]
00002c  428a              CMP      r2,r1
00002e  d300              BCC      |L5.50|
;;;795    		{
;;;796    			_pUart->usRxWrite = 0;
000030  82e5              STRH     r5,[r4,#0x16]
                  |L5.50|
;;;797    		}
;;;798    		if (_pUart->usRxCount < _pUart->usRxBufSize)
000032  8b62              LDRH     r2,[r4,#0x1a]
000034  428a              CMP      r2,r1
000036  d202              BCS      |L5.62|
;;;799    		{
;;;800    			_pUart->usRxCount++;
000038  8b61              LDRH     r1,[r4,#0x1a]
00003a  1c49              ADDS     r1,r1,#1
00003c  8361              STRH     r1,[r4,#0x1a]
                  |L5.62|
;;;801    		}
;;;802    
;;;803    		/* 回调函数,通知应用程序收到新数据,一般是发送1个消息或者设置一个标记 */
;;;804    		//if (_pUart->usRxWrite == _pUart->usRxRead)
;;;805    		//if (_pUart->usRxCount == 1)
;;;806    		{
;;;807    			if (_pUart->ReciveNew)
00003e  6a61              LDR      r1,[r4,#0x24]
000040  b101              CBZ      r1,|L5.68|
;;;808    			{
;;;809    				_pUart->ReciveNew(ch);
000042  4788              BLX      r1
                  |L5.68|
;;;810    			}
;;;811    		}
;;;812    	}
;;;813    
;;;814    	/* 处理发送缓冲区空中断 */
;;;815    	if (USART_GetITStatus(_pUart->uart, USART_IT_TXE) != RESET)
000044  f2407727          MOV      r7,#0x727
000048  4639              MOV      r1,r7
00004a  6820              LDR      r0,[r4,#0]
00004c  f7fffffe          BL       USART_GetITStatus
;;;816    	{
;;;817    		//if (_pUart->usTxRead == _pUart->usTxWrite)
;;;818    		if (_pUart->usTxCount == 0)
;;;819    		{
;;;820    			/* 发送缓冲区的数据已取完时， 禁止发送缓冲区空中断 （注意：此时最后1个数据还未真正发送完毕）*/
;;;821    			USART_ITConfig(_pUart->uart, USART_IT_TXE, DISABLE);
;;;822    
;;;823    			/* 使能数据发送完毕中断 */
;;;824    			USART_ITConfig(_pUart->uart, USART_IT_TC, ENABLE);
000050  f2406626          MOV      r6,#0x626
000054  b190              CBZ      r0,|L5.124|
000056  8aa0              LDRH     r0,[r4,#0x14]         ;818
000058  b9c0              CBNZ     r0,|L5.140|
00005a  2200              MOVS     r2,#0                 ;821
00005c  4639              MOV      r1,r7                 ;821
00005e  6820              LDR      r0,[r4,#0]            ;821
000060  f7fffffe          BL       USART_ITConfig
000064  4631              MOV      r1,r6
000066  6820              LDR      r0,[r4,#0]
000068  e8bd41f0          POP      {r4-r8,lr}
00006c  2201              MOVS     r2,#1
00006e  f7ffbffe          B.W      USART_ITConfig
                  |L5.114|
;;;825    		}
;;;826    		else
;;;827    		{
;;;828    			/* 从发送FIFO取1个字节写入串口发送数据寄存器 */
;;;829    			USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
;;;830    			if (++_pUart->usTxRead >= _pUart->usTxBufSize)
;;;831    			{
;;;832    				_pUart->usTxRead = 0;
;;;833    			}
;;;834    			_pUart->usTxCount--;
000072  8aa0              LDRH     r0,[r4,#0x14]
000074  1e40              SUBS     r0,r0,#1
000076  82a0              STRH     r0,[r4,#0x14]
                  |L5.120|
;;;835    		}
;;;836    
;;;837    	}
;;;838    	/* 数据bit位全部发送完毕的中断 */
;;;839    	else if (USART_GetITStatus(_pUart->uart, USART_IT_TC) != RESET)
;;;840    	{
;;;841    		//if (_pUart->usTxRead == _pUart->usTxWrite)
;;;842    		if (_pUart->usTxCount == 0)
;;;843    		{
;;;844    			/* 如果发送FIFO的数据全部发送完毕，禁止数据发送完毕中断 */
;;;845    			USART_ITConfig(_pUart->uart, USART_IT_TC, DISABLE);
;;;846    
;;;847    			/* 回调函数, 一般用来处理RS485通信，将RS485芯片设置为接收模式，避免抢占总线 */
;;;848    			if (_pUart->SendOver)
;;;849    			{
;;;850    				_pUart->SendOver();
;;;851    			}
;;;852    		}
;;;853    		else
;;;854    		{
;;;855    			/* 正常情况下，不会进入此分支 */
;;;856    
;;;857    			/* 如果发送FIFO的数据还未完毕，则从发送FIFO取1个数据写入发送数据寄存器 */
;;;858    			USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
;;;859    			if (++_pUart->usTxRead >= _pUart->usTxBufSize)
;;;860    			{
;;;861    				_pUart->usTxRead = 0;
;;;862    			}
;;;863    			_pUart->usTxCount--;
;;;864    		}
;;;865    	}
;;;866    }
000078  e8bd81f0          POP      {r4-r8,pc}
                  |L5.124|
00007c  4631              MOV      r1,r6                 ;839
00007e  6820              LDR      r0,[r4,#0]            ;839
000080  f7fffffe          BL       USART_GetITStatus
000084  2800              CMP      r0,#0                 ;839
000086  d0f7              BEQ      |L5.120|
000088  8aa0              LDRH     r0,[r4,#0x14]         ;842
00008a  b170              CBZ      r0,|L5.170|
                  |L5.140|
00008c  8a61              LDRH     r1,[r4,#0x12]         ;858
00008e  6860              LDR      r0,[r4,#4]            ;858
000090  5c41              LDRB     r1,[r0,r1]            ;858
000092  6820              LDR      r0,[r4,#0]            ;858
000094  f7fffffe          BL       USART_SendData
000098  8a60              LDRH     r0,[r4,#0x12]         ;859
00009a  1c40              ADDS     r0,r0,#1              ;859
00009c  b280              UXTH     r0,r0                 ;859
00009e  8260              STRH     r0,[r4,#0x12]         ;859
0000a0  89a1              LDRH     r1,[r4,#0xc]          ;859
0000a2  4288              CMP      r0,r1                 ;859
0000a4  d3e5              BCC      |L5.114|
0000a6  8265              STRH     r5,[r4,#0x12]         ;861
0000a8  e7e3              B        |L5.114|
                  |L5.170|
0000aa  2200              MOVS     r2,#0                 ;845
0000ac  4631              MOV      r1,r6                 ;845
0000ae  6820              LDR      r0,[r4,#0]            ;845
0000b0  f7fffffe          BL       USART_ITConfig
0000b4  6a20              LDR      r0,[r4,#0x20]         ;848
0000b6  2800              CMP      r0,#0                 ;848
0000b8  d0de              BEQ      |L5.120|
0000ba  e8bd41f0          POP      {r4-r8,lr}            ;850
0000be  4700              BX       r0                    ;850
;;;867    
                          ENDP


                          AREA ||i.UartVarInit||, CODE, READONLY, ALIGN=2

                  UartVarInit PROC
;;;254    */
;;;255    static void UartVarInit(void)
000000  4917              LDR      r1,|L6.96|
;;;256    {
;;;257    #if UART1_FIFO_EN == 1
;;;258    	g_tUart1.uart = USART1;						/* STM32 串口设备 */
000002  4816              LDR      r0,|L6.92|
;;;259    	g_tUart1.pTxBuf = g_TxBuf1;					/* 发送缓冲区指针 */
;;;260    	g_tUart1.pRxBuf = g_RxBuf1;					/* 接收缓冲区指针 */
;;;261    	g_tUart1.usTxBufSize = UART1_TX_BUF_SIZE;	/* 发送缓冲区大小 */
000004  f44f6280          MOV      r2,#0x400
000008  6008              STR      r0,[r1,#0]            ;259  ; g_tUart1
00000a  f1010028          ADD      r0,r1,#0x28           ;259
00000e  6048              STR      r0,[r1,#4]            ;260  ; g_tUart1
000010  f5006080          ADD      r0,r0,#0x400          ;260
000014  6088              STR      r0,[r1,#8]  ; g_tUart1
000016  818a              STRH     r2,[r1,#0xc]
;;;262    	g_tUart1.usRxBufSize = UART1_RX_BUF_SIZE;	/* 接收缓冲区大小 */
000018  81ca              STRH     r2,[r1,#0xe]
;;;263    	g_tUart1.usTxWrite = 0;						/* 发送FIFO写索引 */
00001a  2000              MOVS     r0,#0
00001c  8208              STRH     r0,[r1,#0x10]
;;;264    	g_tUart1.usTxRead = 0;						/* 发送FIFO读索引 */
00001e  8248              STRH     r0,[r1,#0x12]
;;;265    	g_tUart1.usRxWrite = 0;						/* 接收FIFO写索引 */
000020  82c8              STRH     r0,[r1,#0x16]
;;;266    	g_tUart1.usRxRead = 0;						/* 接收FIFO读索引 */
000022  8308              STRH     r0,[r1,#0x18]
;;;267    	g_tUart1.usRxCount = 0;						/* 接收到的新数据个数 */
000024  8348              STRH     r0,[r1,#0x1a]
;;;268    	g_tUart1.usTxCount = 0;						/* 待发送的数据个数 */
000026  8288              STRH     r0,[r1,#0x14]
;;;269    	g_tUart1.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;270    	g_tUart1.SendOver = 0;						/* 发送完毕后的回调函数 */
000028  61c8              STR      r0,[r1,#0x1c]  ; g_tUart1
;;;271    	g_tUart1.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
00002a  6208              STR      r0,[r1,#0x20]  ; g_tUart1
;;;272    #endif
;;;273    
;;;274    #if UART2_FIFO_EN == 1
;;;275    	g_tUart2.uart = USART2;						/* STM32 串口设备 */
00002c  6248              STR      r0,[r1,#0x24]  ; g_tUart1
00002e  f6010128          ADD      r1,r1,#0x828
000032  4b0c              LDR      r3,|L6.100|
;;;276    	g_tUart2.pTxBuf = g_TxBuf2;					/* 发送缓冲区指针 */
000034  600b              STR      r3,[r1,#0]  ; g_tUart2
000036  f1010328          ADD      r3,r1,#0x28
;;;277    	g_tUart2.pRxBuf = g_RxBuf2;					/* 接收缓冲区指针 */
00003a  604b              STR      r3,[r1,#4]  ; g_tUart2
00003c  f5016385          ADD      r3,r1,#0x428
;;;278    	g_tUart2.usTxBufSize = UART2_TX_BUF_SIZE;	/* 发送缓冲区大小 */
000040  608b              STR      r3,[r1,#8]  ; g_tUart2
000042  818a              STRH     r2,[r1,#0xc]
;;;279    	g_tUart2.usRxBufSize = UART2_RX_BUF_SIZE;	/* 接收缓冲区大小 */
000044  81ca              STRH     r2,[r1,#0xe]
;;;280    	g_tUart2.usTxWrite = 0;						/* 发送FIFO写索引 */
000046  8208              STRH     r0,[r1,#0x10]
;;;281    	g_tUart2.usTxRead = 0;						/* 发送FIFO读索引 */
000048  8248              STRH     r0,[r1,#0x12]
;;;282    	g_tUart2.usRxWrite = 0;						/* 接收FIFO写索引 */
00004a  82c8              STRH     r0,[r1,#0x16]
;;;283    	g_tUart2.usRxRead = 0;						/* 接收FIFO读索引 */
00004c  8308              STRH     r0,[r1,#0x18]
;;;284    	g_tUart2.usRxCount = 0;						/* 接收到的新数据个数 */
00004e  8348              STRH     r0,[r1,#0x1a]
;;;285    	g_tUart2.usTxCount = 0;						/* 待发送的数据个数 */
000050  8288              STRH     r0,[r1,#0x14]
;;;286    	g_tUart2.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;287    	g_tUart2.SendOver = 0;						/* 发送完毕后的回调函数 */
000052  61c8              STR      r0,[r1,#0x1c]  ; g_tUart2
;;;288    	g_tUart2.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
000054  6208              STR      r0,[r1,#0x20]  ; g_tUart2
000056  6248              STR      r0,[r1,#0x24]  ; g_tUart2
;;;289    #endif
;;;290    
;;;291    #if UART3_FIFO_EN == 1
;;;292    	g_tUart3.uart = USART3;						/* STM32 串口设备 */
;;;293    	g_tUart3.pTxBuf = g_TxBuf3;					/* 发送缓冲区指针 */
;;;294    	g_tUart3.pRxBuf = g_RxBuf3;					/* 接收缓冲区指针 */
;;;295    	g_tUart3.usTxBufSize = UART3_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;296    	g_tUart3.usRxBufSize = UART3_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;297    	g_tUart3.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;298    	g_tUart3.usTxRead = 0;						/* 发送FIFO读索引 */
;;;299    	g_tUart3.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;300    	g_tUart3.usRxRead = 0;						/* 接收FIFO读索引 */
;;;301    	g_tUart3.usRxCount = 0;						/* 接收到的新数据个数 */
;;;302    	g_tUart3.usTxCount = 0;						/* 待发送的数据个数 */
;;;303    	g_tUart3.SendBefor = 0;		/* 发送数据前的回调函数 */
;;;304    	g_tUart3.SendOver = 0;			/* 发送完毕后的回调函数 */
;;;305    	g_tUart3.ReciveNew = 0;		/* 接收到新数据后的回调函数 */
;;;306    #endif
;;;307    
;;;308    #if UART4_FIFO_EN == 1
;;;309    	g_tUart4.uart = UART4;						/* STM32 串口设备 */
;;;310    	g_tUart4.pTxBuf = g_TxBuf4;					/* 发送缓冲区指针 */
;;;311    	g_tUart4.pRxBuf = g_RxBuf4;					/* 接收缓冲区指针 */
;;;312    	g_tUart4.usTxBufSize = UART4_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;313    	g_tUart4.usRxBufSize = UART4_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;314    	g_tUart4.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;315    	g_tUart4.usTxRead = 0;						/* 发送FIFO读索引 */
;;;316    	g_tUart4.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;317    	g_tUart4.usRxRead = 0;						/* 接收FIFO读索引 */
;;;318    	g_tUart4.usRxCount = 0;						/* 接收到的新数据个数 */
;;;319    	g_tUart4.usTxCount = 0;						/* 待发送的数据个数 */
;;;320    	g_tUart4.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;321    	g_tUart4.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;322    	g_tUart4.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;323    #endif
;;;324    
;;;325    #if UART5_FIFO_EN == 1
;;;326    	g_tUart5.uart = UART5;						/* STM32 串口设备 */
;;;327    	g_tUart5.pTxBuf = g_TxBuf5;					/* 发送缓冲区指针 */
;;;328    	g_tUart5.pRxBuf = g_RxBuf5;					/* 接收缓冲区指针 */
;;;329    	g_tUart5.usTxBufSize = UART5_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;330    	g_tUart5.usRxBufSize = UART5_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;331    	g_tUart5.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;332    	g_tUart5.usTxRead = 0;						/* 发送FIFO读索引 */
;;;333    	g_tUart5.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;334    	g_tUart5.usRxRead = 0;						/* 接收FIFO读索引 */
;;;335    	g_tUart5.usRxCount = 0;						/* 接收到的新数据个数 */
;;;336    	g_tUart5.usTxCount = 0;						/* 待发送的数据个数 */
;;;337    	g_tUart5.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;338    	g_tUart5.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;339    	g_tUart5.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;340    #endif
;;;341    
;;;342    
;;;343    #if UART6_FIFO_EN == 1
;;;344    	g_tUart6.uart = USART6;						/* STM32 串口设备 */
;;;345    	g_tUart6.pTxBuf = g_TxBuf6;					/* 发送缓冲区指针 */
;;;346    	g_tUart6.pRxBuf = g_RxBuf6;					/* 接收缓冲区指针 */
;;;347    	g_tUart6.usTxBufSize = UART6_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;348    	g_tUart6.usRxBufSize = UART6_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;349    	g_tUart6.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;350    	g_tUart6.usTxRead = 0;						/* 发送FIFO读索引 */
;;;351    	g_tUart6.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;352    	g_tUart6.usRxRead = 0;						/* 接收FIFO读索引 */
;;;353    	g_tUart6.usRxCount = 0;						/* 接收到的新数据个数 */
;;;354    	g_tUart6.usTxCount = 0;						/* 待发送的数据个数 */
;;;355    	g_tUart6.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;356    	g_tUart6.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;357    	g_tUart6.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;358    #endif
;;;359    }
000058  4770              BX       lr
;;;360    
                          ENDP

00005a  0000              DCW      0x0000
                  |L6.92|
                          DCD      0x40013800
                  |L6.96|
                          DCD      ||.bss||
                  |L6.100|
                          DCD      0x40004400

                          AREA ||i.bsp_InitUart||, CODE, READONLY, ALIGN=1

                  bsp_InitUart PROC
;;;64     */
;;;65     void bsp_InitUart(void)
000000  b538              PUSH     {r3-r5,lr}
;;;66     {
;;;67     	UartVarInit();		/* 必须先初始化全局变量,再配置硬件 */
000002  f7fffffe          BL       UartVarInit
;;;68     
;;;69     	InitHardUart();		/* 配置串口的硬件参数(波特率等) */
000006  f7fffffe          BL       InitHardUart
00000a  2025              MOVS     r0,#0x25
00000c  f88d0000          STRB     r0,[sp,#0]
000010  2000              MOVS     r0,#0
000012  f88d0002          STRB     r0,[sp,#2]
000016  2401              MOVS     r4,#1
000018  f88d4003          STRB     r4,[sp,#3]
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       NVIC_Init
000022  2026              MOVS     r0,#0x26
000024  f88d0000          STRB     r0,[sp,#0]
000028  f88d4002          STRB     r4,[sp,#2]
00002c  f88d4003          STRB     r4,[sp,#3]
000030  4668              MOV      r0,sp
000032  f7fffffe          BL       NVIC_Init
;;;70     
;;;71     	ConfigUartNVIC();	/* 配置串口中断 */
;;;72     }
000036  bd38              POP      {r3-r5,pc}
;;;73     
                          ENDP


                          AREA ||i.comClearRxFifo||, CODE, READONLY, ALIGN=1

                  comClearRxFifo PROC
;;;225    */
;;;226    void comClearRxFifo(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;227    {
;;;228    	UART_T *pUart;
;;;229    
;;;230    	pUart = ComToUart(_ucPort);
000002  f7fffffe          BL       ComToUart
;;;231    	if (pUart == 0)
000006  2800              CMP      r0,#0
000008  d003              BEQ      |L8.18|
;;;232    	{
;;;233    		return;
;;;234    	}
;;;235    
;;;236    	pUart->usRxWrite = 0;
00000a  2100              MOVS     r1,#0
00000c  82c1              STRH     r1,[r0,#0x16]
;;;237    	pUart->usRxRead = 0;
00000e  8301              STRH     r1,[r0,#0x18]
;;;238    	pUart->usRxCount = 0;
000010  8341              STRH     r1,[r0,#0x1a]
                  |L8.18|
;;;239    	
;;;240    	//memset(pUart->pRxBuf,0,UART1_RX_BUF_SIZE);
;;;241    }
000012  bd00              POP      {pc}
;;;242    
                          ENDP


                          AREA ||i.comClearTxFifo||, CODE, READONLY, ALIGN=1

                  comClearTxFifo PROC
;;;202    */
;;;203    void comClearTxFifo(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;204    {
;;;205    	UART_T *pUart;
;;;206    
;;;207    	pUart = ComToUart(_ucPort);
000002  f7fffffe          BL       ComToUart
;;;208    	if (pUart == 0)
000006  2800              CMP      r0,#0
000008  d003              BEQ      |L9.18|
;;;209    	{
;;;210    		return;
;;;211    	}
;;;212    
;;;213    	pUart->usTxWrite = 0;
00000a  2100              MOVS     r1,#0
00000c  8201              STRH     r1,[r0,#0x10]
;;;214    	pUart->usTxRead = 0;
00000e  8241              STRH     r1,[r0,#0x12]
;;;215    	pUart->usTxCount = 0;
000010  8281              STRH     r1,[r0,#0x14]
                  |L9.18|
;;;216    }
000012  bd00              POP      {pc}
;;;217    
                          ENDP


                          AREA ||i.comGetChar||, CODE, READONLY, ALIGN=1

                  comGetChar PROC
;;;181    */
;;;182    uint8_t comGetChar(COM_PORT_E _ucPort, uint8_t *_pByte)
000000  b510              PUSH     {r4,lr}
;;;183    {
;;;184    	UART_T *pUart;
;;;185    
;;;186    	pUart = ComToUart(_ucPort);
000002  f7fffffe          BL       ComToUart
;;;187    	if (pUart == 0)
000006  2800              CMP      r0,#0
000008  d01f              BEQ      |L10.74|
;;;188    	{
;;;189    		return 0;
;;;190    	}
;;;191    
;;;192    	return UartGetChar(pUart, _pByte);
00000a  4602              MOV      r2,r0
00000c  2001              MOVS     r0,#1
00000e  f3808810          MSR      PRIMASK,r0
000012  8b53              LDRH     r3,[r2,#0x1a]
000014  2000              MOVS     r0,#0
000016  f3808810          MSR      PRIMASK,r0
00001a  2b00              CMP      r3,#0
00001c  d015              BEQ      |L10.74|
00001e  8b14              LDRH     r4,[r2,#0x18]
000020  6893              LDR      r3,[r2,#8]
000022  5d1b              LDRB     r3,[r3,r4]
000024  700b              STRB     r3,[r1,#0]
000026  2101              MOVS     r1,#1
000028  f3818810          MSR      PRIMASK,r1
00002c  8b11              LDRH     r1,[r2,#0x18]
00002e  1c49              ADDS     r1,r1,#1
000030  b289              UXTH     r1,r1
000032  8311              STRH     r1,[r2,#0x18]
000034  89d3              LDRH     r3,[r2,#0xe]
000036  4299              CMP      r1,r3
000038  d300              BCC      |L10.60|
00003a  8310              STRH     r0,[r2,#0x18]
                  |L10.60|
00003c  8b50              LDRH     r0,[r2,#0x1a]
00003e  1e40              SUBS     r0,r0,#1
000040  8350              STRH     r0,[r2,#0x1a]
000042  2000              MOVS     r0,#0
000044  f3808810          MSR      PRIMASK,r0
000048  2001              MOVS     r0,#1
                  |L10.74|
;;;193    }
00004a  bd10              POP      {r4,pc}
;;;194    
                          ENDP


                          AREA ||i.comSendBuf||, CODE, READONLY, ALIGN=1

                  comSendBuf PROC
;;;140    */
;;;141    void comSendBuf(COM_PORT_E _ucPort, uint8_t *_ucaBuf, uint16_t _usLen)
000000  b5f8              PUSH     {r3-r7,lr}
;;;142    {
000002  4615              MOV      r5,r2
000004  460e              MOV      r6,r1
;;;143    	UART_T *pUart;
;;;144    
;;;145    	pUart = ComToUart(_ucPort);
000006  f7fffffe          BL       ComToUart
00000a  0004              MOVS     r4,r0
;;;146    	if (pUart == 0)
00000c  d034              BEQ      |L11.120|
;;;147    	{
;;;148    		return;
;;;149    	}
;;;150    
;;;151    	if (pUart->SendBefor != 0)
00000e  69e0              LDR      r0,[r4,#0x1c]
000010  b100              CBZ      r0,|L11.20|
;;;152    	{
;;;153    		pUart->SendBefor();		/* 如果是RS485通信，可以在这个函数中将RS485设置为发送模式 */
000012  4780              BLX      r0
                  |L11.20|
000014  2000              MOVS     r0,#0
;;;154    	}
;;;155    
;;;156    	UartSend(pUart, _ucaBuf, _usLen);
000016  e025              B        |L11.100|
                  |L11.24|
000018  89a1              LDRH     r1,[r4,#0xc]
                  |L11.26|
00001a  2201              MOVS     r2,#1
00001c  f3828810          MSR      PRIMASK,r2
000020  8aa2              LDRH     r2,[r4,#0x14]
000022  f8ad2000          STRH     r2,[sp,#0]
000026  2200              MOVS     r2,#0
000028  f3828810          MSR      PRIMASK,r2
00002c  f8bd2000          LDRH     r2,[sp,#0]
000030  4291              CMP      r1,r2
000032  d9f2              BLS      |L11.26|
000034  5c31              LDRB     r1,[r6,r0]
000036  8a23              LDRH     r3,[r4,#0x10]
000038  6862              LDR      r2,[r4,#4]
00003a  54d1              STRB     r1,[r2,r3]
00003c  2101              MOVS     r1,#1
00003e  f3818810          MSR      PRIMASK,r1
000042  8a21              LDRH     r1,[r4,#0x10]
000044  1c49              ADDS     r1,r1,#1
000046  b289              UXTH     r1,r1
000048  8221              STRH     r1,[r4,#0x10]
00004a  89a2              LDRH     r2,[r4,#0xc]
00004c  4291              CMP      r1,r2
00004e  d301              BCC      |L11.84|
000050  2100              MOVS     r1,#0
000052  8221              STRH     r1,[r4,#0x10]
                  |L11.84|
000054  8aa1              LDRH     r1,[r4,#0x14]
000056  1c49              ADDS     r1,r1,#1
000058  82a1              STRH     r1,[r4,#0x14]
00005a  2100              MOVS     r1,#0
00005c  f3818810          MSR      PRIMASK,r1
000060  1c40              ADDS     r0,r0,#1
000062  b280              UXTH     r0,r0
                  |L11.100|
000064  42a8              CMP      r0,r5
000066  d3d7              BCC      |L11.24|
000068  6820              LDR      r0,[r4,#0]
00006a  e8bd40f8          POP      {r3-r7,lr}
00006e  2201              MOVS     r2,#1
000070  f2407127          MOV      r1,#0x727
000074  f7ffbffe          B.W      USART_ITConfig
                  |L11.120|
;;;157    }
000078  bdf8              POP      {r3-r7,pc}
;;;158    
                          ENDP


                          AREA ||i.comSendChar||, CODE, READONLY, ALIGN=1

                  comSendChar PROC
;;;167    */
;;;168    void comSendChar(COM_PORT_E _ucPort, uint8_t _ucByte)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;169    {
;;;170    	comSendBuf(_ucPort, &_ucByte, 1);
000002  2201              MOVS     r2,#1
000004  a901              ADD      r1,sp,#4
000006  f7fffffe          BL       comSendBuf
;;;171    }
00000a  bd1c              POP      {r2-r4,pc}
;;;172    
                          ENDP


                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=1

                  fgetc PROC
;;;951    */
;;;952    int fgetc(FILE *f)
000000  b508              PUSH     {r3,lr}
                  |L13.2|
;;;953    {
;;;954    
;;;955    #if 1	/* 从串口接收FIFO中取1个数据, 只有取到数据才返回 */
;;;956    	uint8_t ucData;
;;;957    
;;;958    	while(comGetChar(COM1, &ucData) == 0);
000002  4669              MOV      r1,sp
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       comGetChar
00000a  2800              CMP      r0,#0
00000c  d0f9              BEQ      |L13.2|
;;;959    
;;;960    	return ucData;
00000e  f89d0000          LDRB     r0,[sp,#0]
;;;961    #else
;;;962    	/* 等待串口1输入数据 */
;;;963    	while (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET);
;;;964    
;;;965    	return (int)USART_ReceiveData(USART1);
;;;966    #endif
;;;967    }
000012  bd08              POP      {r3,pc}
;;;968    
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=1

                  fputc PROC
;;;925    */
;;;926    int fputc(int ch, FILE *f)
000000  b510              PUSH     {r4,lr}
;;;927    {
000002  4604              MOV      r4,r0
;;;928    #if 1	/* 将需要printf的字符通过串口中断FIFO发送出去，printf函数会立即返回 */
;;;929    	comSendChar(COM1, ch);
000004  b2c1              UXTB     r1,r0
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       comSendChar
;;;930    
;;;931    	return ch;
00000c  4620              MOV      r0,r4
;;;932    #else	/* 采用阻塞方式发送每个字符,等待数据发送完毕 */
;;;933    	/* 写一个字节到USART1 */
;;;934    	USART_SendData(USART1, (uint8_t) ch);
;;;935    
;;;936    	/* 等待发送结束 */
;;;937    	while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET)
;;;938    	{}
;;;939    
;;;940    	return ch;
;;;941    #endif
;;;942    }
00000e  bd10              POP      {r4,pc}
;;;943    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_tUart1
                          %        40
                  g_TxBuf1
                          %        1024
                  g_RxBuf1
                          %        1024
                  g_tUart2
                          %        40
                  g_TxBuf2
                          %        1024
                  g_RxBuf2
                          %        1024

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_uart_fifo.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_b28b0d00____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_bsp_uart_fifo_c_b28b0d00____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_b28b0d00____REVSH|
#line 128
|__asm___15_bsp_uart_fifo_c_b28b0d00____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
